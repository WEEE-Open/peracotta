#!/usr/bin/env python3
from PyQt5 import uic, QtWidgets, QtCore, QtGui
from PyQt5.QtCore import QAbstractTableModel
from collections import defaultdict
from os.path import expanduser
from pytarallo import Tarallo
from pytarallo.Errors import NoInternetConnectionError
from dotenv import load_dotenv
from os import environ as env
import os
import urllib.parse
import sys
import traceback
import json
import prettyprinter
import peracommon

# TODO: peracruda/58 call parsers
# TODO: peracruda/63 set owner to everything
# TODO: peracruda/66 split_products returns the list of product
# TODO: peracommon.unmake_tree if JSON loaded
# TODO: peracommon.make_tree before upload


VERSION = "2.0"

URL = {
    "website": "https://weeeopen.polito.it",
    "source_code": "https://github.com/WEEE-Open/peracotta",
}

PATH = {
    "UI": "assets/interface.ui",
    "TARALLOUPLOADDIALOG": "assets/uploadTaralloDialog.ui",
    "JSON": "copy_this_to_tarallo.json",
    "FEATURES": "features.json",
    "THEMES": "assets/themes/",
    "TMP_FILES": "tmp/",
}

ICON = {
    "case": "assets/toolbox/case.png",
    "ram": "assets/toolbox/ram.png",
    "cpu": "assets/toolbox/cpu.png",
    "graphics-card": "assets/toolbox/gpu.png",
    "odd": "assets/toolbox/odd.png",
    "hard disk": "assets/toolbox/hard disk.png",
    "motherboard": "assets/toolbox/motherboard.png",
    "wifi-card": "assets/toolbox/wifi-card.png",
    "psu": "assets/toolbox/psu.png",
    "monitor": "assets/toolbox/monitor.png",
    "keyboard": "assets/toolbox/keyboard.png",
    "mouse": "assets/toolbox/mouse.png",
}

DEFAULT_PROGRESS_BAR_STYLE = (
    "QStatusBar::item {"
    "min-height: 12px;"
    "max-height: 12px;"
    "}"
    "QProgressBar {"
    "min-height: 14px;"
    "max-height: 14px;"
    "}"
    "QProgressBar::chunk {"
    "background-color: #00963A;"
    "width: 50px;"
    "}"
)


class Ui(QtWidgets.QMainWindow):
    def __init__(
        self, app: QtWidgets.QApplication, tarallo_url: str, tarallo_token: str
    ) -> None:
        super(Ui, self).__init__()
        uic.loadUi(PATH["UI"], self)
        self.app = app
        self.taralloDialog = None
        self.data = None
        self.tarallo_url = tarallo_url
        self.tarallo_token = tarallo_token
        # self.selectors = dict()
        self.useful_default_features = dict()
        self.encountered_types_count = defaultdict(lambda: 0)
        self.encountered_types_current_count = defaultdict(lambda: 0)
        # self.app.setStyle("Fusion")

        # Output toolbox
        self.itemToolBox = self.findChild(QtWidgets.QToolBox, "itemToolBox")

        # App settings
        self.settings = QtCore.QSettings("WEEE Open", "PERACOTTA")

        # Gpu location layout
        self.gpuGroupBox = self.findChild(QtWidgets.QGroupBox, "gpuGroupBox")

        # Radio buttons
        self.discreteRadioBtn = self.findChild(
            QtWidgets.QRadioButton, "discreteRadioBtn"
        )
        self.intCpuRadioBtn = self.findChild(QtWidgets.QRadioButton, "intCpuRadioBtn")
        self.intMoboRadioBtn = self.findChild(QtWidgets.QRadioButton, "intMoboRadioBtn")

        # Selectors area
        self.selectorsWidget = self.findChild(QtWidgets.QWidget, "selectorsWidget")
        self.selectorsScrollArea = self.findChild(
            QtWidgets.QScrollArea, "selectorsScrollArea"
        )

        self.addItemComboBox = self.findChild(QtWidgets.QComboBox, "addItemComboBox")
        self.addItemComboBox.addItem("Select Type --")
        for checkbox in self.selectorsWidget.findChildren(QtWidgets.QCheckBox):
            self.addItemComboBox.addItem(checkbox.text())
            icon = QtGui.QIcon(ICON[checkbox.text().lower()])
            self.addItemComboBox.setItemIcon(self.addItemComboBox.count() - 1, icon)
        self.addItemComboBox.currentTextChanged.connect(self.add_toolbox_item)
        self.addItemComboBox.wheelEvent = lambda stop_wheel_event: None

        # Owner line edit
        self.ownerLineEdit = self.findChild(QtWidgets.QLineEdit, "ownerLineEdit")

        # Generate data button
        self.generateBtn = self.findChild(QtWidgets.QPushButton, "generateBtn")
        self.generateBtn.clicked.connect(self.generate)

        # Reset selectors button
        self.resetBtn = self.findChild(QtWidgets.QPushButton, "resetBtn")
        self.resetBtn.clicked.connect(self.reset_setup_group)

        # Save JSON button
        self.saveJsonBtn = self.findChild(QtWidgets.QPushButton, "saveJsonBtn")
        self.saveJsonBtn.clicked.connect(self.save_json)

        # Upload to tarallo button
        self.uploadBtn = self.findChild(QtWidgets.QPushButton, "uploadBtn")
        self.uploadBtn.clicked.connect(self.tarallo_dialog)

        # File actions
        self.actionOpen = self.findChild(QtWidgets.QAction, "actionOpen")
        self.actionOpen.triggered.connect(self.open_json)
        self.actionOpenLastJson = self.findChild(
            QtWidgets.QAction, "actionOpenLastJson"
        )
        self.actionOpenLastJson.triggered.connect(self.open_latest_json)
        self.actionOpenJson = self.findChild(QtWidgets.QAction, "actionOpenJson")
        self.actionOpenJson.triggered.connect(self.show_json)
        self.actionLoadRawFiles = self.findChild(
            QtWidgets.QAction, "actionLoadRawFiles"
        )
        self.actionLoadRawFiles.triggered.connect(self.load_raw_files)
        self.actionExit = self.findChild(QtWidgets.QAction, "actionExit")
        self.actionExit.triggered.connect(self.close)

        # Options actions
        self.menuTheme = self.findChild(QtWidgets.QMenu, "menuTheme")
        action = self.menuTheme.addAction("Default")
        action.triggered.connect(lambda: self.set_theme("default"))
        for theme_file in os.listdir(PATH["THEMES"]):
            theme = theme_file.rstrip(".css")
            action = self.menuTheme.addAction(theme.title())
            action.triggered.connect(lambda: self.set_theme(theme))

        # Help actions
        self.actionAboutUs = self.findChild(QtWidgets.QAction, "actionAboutUs")
        self.actionAboutUs.triggered.connect(self.open_website)
        self.actionSourceCode = self.findChild(QtWidgets.QAction, "actionSourceCode")
        self.actionSourceCode.triggered.connect(self.open_source_code)
        self.actionVersion = self.findChild(QtWidgets.QAction, "actionVersion")
        self.actionVersion.triggered.connect(self.show_version)

        # Status bar widgets
        self.progressBar = QtWidgets.QProgressBar()
        self.statusBar().addPermanentWidget(self.progressBar)
        self.progressBar.hide()
        # self.statusBar().setStyleSheet(DEFAULT_PROGRESS_BAR_STYLE)

        # Setup peracotta QThread
        self.peracotta = Peracotta(
            self.discreteRadioBtn,
            self.intCpuRadioBtn,
            self.ownerLineEdit,
            PATH["TMP_FILES"],
        )
        self.peracotta.updateEvent.connect(self.peracotta_results)
        self.peracotta.startEvent.connect(self.show_busy_progress_bar)

        self.show()
        self.setup()

    def setup(self):
        try:
            self.reset_toolbox()
            with open(PATH["FEATURES"], "r") as file:
                default_feature_names = {}
                default_feature_types = {}
                default_feature_values = {}
                default_features = json.load(file)
                for group in default_features["features"]:
                    for feature in default_features["features"][group]:
                        name = feature["name"]
                        default_feature_names[name] = feature["printableName"]
                        default_feature_types[name] = feature["type"]
                        if "values" in feature:
                            default_feature_values[name] = feature["values"]
                self.useful_default_features = {
                    "names": default_feature_names,
                    "types": default_feature_types,
                    "values": default_feature_values,
                }
                layout = self.selectorsWidget.layout()
                for item in peracommon.ParserComponents:
                    layout.addWidget(QtWidgets.QCheckBox(item.value))

                self.reset_setup_group()

        except FileNotFoundError:
            print("DOWNLOAD THE THING FROM TARALLO NOW!")
            useful_default_features = {}

        if self.data is None:
            return

    # gui utilities
    def set_toolbox(self, data: list = None):
        if data is not None:
            self.data = data
        self.types_count()

        # insert items into toolbox widget
        for entry in self.data:
            if entry["type"] != "I":
                continue
            counter = ""
            type = entry["features"]["type"]
            if self.encountered_types_count[type] > 1:
                self.encountered_types_current_count[type] += 1
                counter = f" #{self.encountered_types_current_count[type]}"
            self.itemToolBox.addItem(
                ToolBoxWidget(entry["features"], self.useful_default_features),
                f"{self.print_type_cool(type)}{counter}",
            )
            if type in ICON:
                icon = QtGui.QIcon(ICON[type])
                self.itemToolBox.setItemIcon(self.itemToolBox.count() - 1, icon)

        # remove scroll in toolbox's scrollAreas
        for scroll_area in self.itemToolBox.findChildren(QtWidgets.QScrollArea):
            scroll_area.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
            scroll_area.verticalScrollBar().hide()
            scroll_area.verticalScrollBar().resize(0, 0)

    def reset_toolbox(self):
        for idx in range(self.itemToolBox.count()):
            self.itemToolBox.removeItem(0)

    def open_url(self, url_type: str):
        url = QtCore.QUrl(url_type)
        if not QtGui.QDesktopServices.openUrl(url):
            QtWidgets.QMessageBox.warning(
                self, "Cannot Open Url", f"Could not open url {url_type}"
            )

    def set_theme(self, theme: str):
        if theme == "default":
            self.app.setStyleSheet("")
            return
        with open(f"{PATH['THEMES']}{theme}.css", "r") as file:
            self.app.setStyleSheet(file.read())

    def print_type_cool(self, the_type: str) -> str:
        if the_type in self.useful_default_features["values"]["type"]:
            return self.useful_default_features["values"]["type"][the_type]
        else:
            return the_type.title()

    def show_busy_progress_bar(self):
        self.progressBar.setRange(0, 0)
        self.progressBar.show()

    def types_count(self, data: list = None):
        if data is not None:
            self.data = data
        for entry in self.data:
            if entry["type"] != "I":
                continue
            the_type = entry["features"]["type"]
            self.encountered_types_count[the_type] += 1

    # tarallo utilities
    def upload_to_tarallo(self, checkbox: bool, bulk_id=None):
        if bulk_id == "":
            bulk_id = None
        uploader = Uploader(
            self.data, self.tarallo_url, self.tarallo_token, bulk_id, checkbox
        )
        uploader.successEvent.connect(self.tarallo_success)
        uploader.failureEvent.connect(self.tarallo_failure)

    def tarallo_success(self, code: str):
        url = f"{self.tarallo_url}/bulk/import#{urllib.parse.quote(code)}"
        tarallo_success_dialog(url)

    def tarallo_failure(self, case: str, bulk_id: str):
        if case == "cannot_upload":
            QtWidgets.QMessageBox.warning(
                self,
                "Cannot upload to T.A.R.A.L.L.O.",
                "Cannot upload, try to change the bulk identifier or check the overwrite checkbox.",
            )
            self.tarallo_dialog(bulk_id)
        elif case == "cannot_reach":
            QtWidgets.QMessageBox.warning(
                self,
                "Unable to reach the T.A.R.A.L.L.O.",
                "Please connect this PC to the Internet and try again.",
            )

    # buttons functions
    def reset_setup_group(self):
        # reset gpu location
        for radioBtn in self.gpuGroupBox.findChildren(QtWidgets.QRadioButton):
            radioBtn.setAutoExclusive(False)
            radioBtn.setChecked(False)
            radioBtn.setAutoExclusive(True)

        # reset checkboxes
        defaults = []
        for component in peracommon.ParserComponents:
            if component.name in ["MONITOR", "KEYBOARD", "MOUSE"]:
                continue
            defaults.append(component.value)

        for checkbox in self.selectorsWidget.findChildren(QtWidgets.QCheckBox):
            if checkbox.text() in defaults:
                checkbox.setChecked(True)
            else:
                checkbox.setChecked(False)

        # reset owner
        self.ownerLineEdit.clear()

    def generate(self):
        def warning():
            QtWidgets.QMessageBox.warning(
                self, "Warning", "Please, select one of the GPU locations to proceed."
            )

        if not (
            self.discreteRadioBtn.isChecked()
            or self.intCpuRadioBtn.isChecked()
            or self.intMoboRadioBtn.isChecked()
        ):
            warning()
            return

        self.peracotta.generate_files = True
        self.peracotta.set_filters(self.selectorsWidget)
        self.peracotta.start()
        self.reset_toolbox()

    def save_json(self):
        if self.data is None:
            QtWidgets.QMessageBox.warning(
                self, "Warning", "There is nothing to be saved"
            )
            return
        the_dir = QtWidgets.QFileDialog.getSaveFileName(
            self,
            "Save Peracotta JSON",
            f"{expanduser('~')}",
            "JSON (*.json);;Text file (*.txt);;All Files (*)",
        )
        if the_dir[0] == "":
            return
        with open(the_dir[0], "w") as file:
            file.write(f"{json.dumps(self.data)}")
            file.flush()
            file.close()

    def tarallo_dialog(self, bulk_id=str()):
        if self.data is None:
            QtWidgets.QMessageBox.warning(
                self, "Warning", "There is nothing to be uploaded"
            )
            return
        if not bulk_id:
            bulk_id = ""
        self.taralloDialog = TaralloUploadDialog(bulk_id)
        self.taralloDialog.signal.connect(self.upload_to_tarallo)

    def add_toolbox_item(self):
        if self.addItemComboBox.currentIndex() == 0:
            return
        else:
            type = self.addItemComboBox.currentText().lower()
            if not self.encountered_types_count[type]:
                counter = ""
            else:
                counter = f" #{self.encountered_types_count[type] + 1}"
            self.encountered_types_count[type] += 1

            data = {"type": self.addItemComboBox.currentText().lower()}
            self.itemToolBox.addItem(
                ToolBoxWidget(data, self.useful_default_features),
                f"{self.print_type_cool(type)}{counter}",
            )
            icon = QtGui.QIcon(ICON[type])
            self.itemToolBox.setItemIcon(self.itemToolBox.count() - 1, icon)
            if self.data is None:
                self.data = []
            self.data.append({})
            self.addItemComboBox.setCurrentIndex(0)

    # menu actions
    def open_json(self, path: str = ""):
        self.reset_toolbox()
        if not path:
            the_dir = QtWidgets.QFileDialog.getOpenFileName(
                self,
                "Open JSON",
                f"{expanduser('~')}",
                f"JSON (*.json);;All Files (*)",
            )
            path = the_dir[0]
        if path == "":
            self.data = None
            return
        with open(path, "r") as file:
            self.data = json.load(file)

        self.data = peracommon.unmake_tree(self.data)
        self.settings.setValue("latest_json", path)
        self.set_toolbox()

    def open_latest_json(self):
        for key in self.settings.childKeys():
            if "latest_json" in key:
                self.open_json(self.settings.value("latest_json"))

    def load_raw_files(self):
        print("Loading raw files...")

    def show_json(self):
        if self.data is None:
            return
        JsonWidget(self.data)

    def open_website(self):
        self.open_url(URL["website"])

    def open_source_code(self):
        self.open_url(URL["source_code"])

    def show_version(self):
        QtWidgets.QMessageBox.about(self, "Version", f"Peracotta v{VERSION}")

    # multithread
    def peracotta_results(self, data: list):
        self.progressBar.setRange(0, 1)  # disable statusBar's progressBar
        self.progressBar.hide()
        self.data = data
        self.set_toolbox()
        # checks for wanted items
        # for checkbox in self.selectorsWidget.findChildren(QtWidgets.QCheckBox):
        #     self.selectors.update({checkbox.text().lower(): checkbox.isChecked()})

        # toolbox fill

    # close event
    def closeEvent(self, a0: QtGui.QCloseEvent) -> None:
        if self.peracotta.isRunning():
            self.peracotta.terminate()


class Peracotta(QtCore.QThread):
    updateEvent = QtCore.pyqtSignal(list, name="update")
    startEvent = QtCore.pyqtSignal()

    def __init__(
        self,
        discrete_radio_btn: QtWidgets.QRadioButton,
        int_cpu_radio_btn: QtWidgets.QRadioButton,
        owner_line_edit: QtWidgets.QLineEdit,
        generated_files_path: str,
    ):
        super().__init__()
        self.gpu_location = (
            peracommon.GpuLocation.DISCRETE
            if discrete_radio_btn
            else peracommon.GpuLocation.CPU
            if int_cpu_radio_btn
            else peracommon.GpuLocation.MOTHERBOARD
        )
        self.owner = owner_line_edit.text()
        self.generated_files_path = generated_files_path
        self.generate_files = None

        self.filters = []
        self.the_dir = None
        self.set_default_values()

        self.is_running = False

    def run(self) -> None:
        self.is_running = True
        self.startEvent.emit()
        result = []
        if self.generate_files:
            if sys.platform == "win32":
                from scripts.get_windows_specs import generate_win_files

                generate_win_files()
                self.process_win_files()
            else:
                peracommon.check_required_files(self.generated_files_path)
                self.generated_files_path = peracommon.generate_files(self.the_dir)
                result = peracommon.call_parsers(
                    self.generated_files_path,
                    set(self.filters),
                    self.gpu_location,
                    True,
                )
                if self.owner != "":
                    result = peracommon.add_owner(result, self.owner)
                result = peracommon.split_products(result)
        self.updateEvent.emit(result)
        self.set_default_values()

    def set_default_values(self):
        self.filters = []
        self.generate_files = False
        self.the_dir = "tmp"
        self.is_running = True

    def process_files(self):
        pass

    def process_win_files(self):
        pass

    def set_filters(self, widget: QtWidgets.QWidget):
        for checkbox in widget.findChildren(QtWidgets.QCheckBox):
            if checkbox.isChecked():
                self.filters.append(peracommon.ParserComponents(checkbox.text()))


class CustomTableView(QtWidgets.QTableView):
    def __init__(self):
        super().__init__()

    def minimumSizeHint(self) -> QtCore.QSize:
        default_size = super().minimumSizeHint()

        frame = self.frameWidth() * 2

        header = self.verticalHeader().sizeHint().height()
        rows = self.verticalHeader().length()
        h = header + rows + frame
        # print(f"{header} + {rows} + {frame} = {h} > {default_size.height()}")

        return QtCore.QSize(default_size.width(), h)


class ToolBoxWidget(QtWidgets.QWidget):
    def __init__(self, data: dict, default_features: dict):
        super().__init__()
        self.default_features = default_features

        self.main_layout = QtWidgets.QVBoxLayout()
        self.table = CustomTableView()
        self.features_combo_box = QtWidgets.QComboBox()
        self.feature_line_edit = QtWidgets.QLineEdit()
        self.feature_selector = QtWidgets.QComboBox()
        self.add_feature_button = QtWidgets.QPushButton("Add")
        self.add_feature_button.clicked.connect(self.add_feature)

        # setup
        self.table_setup(data, default_features)
        self.feature_adder(data["type"])
        self.setLayout(self.main_layout)

    def table_setup(self, data: dict, default_features: dict):
        self.table.verticalHeader().hide()
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.setModel(CustomTableModel(data, default_features))
        self.table.setShowGrid(False)
        self.table.setAlternatingRowColors(True)
        self.table.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.table.verticalScrollBar().hide()
        self.table.verticalScrollBar().resize(0, 0)
        self.main_layout.addWidget(self.table)
        self.table.resizeColumnsToContents()

    def feature_adder(self, type: str):
        layout = QtWidgets.QHBoxLayout()
        layout.addWidget(self.features_combo_box)
        layout.addWidget(self.feature_line_edit)
        layout.addWidget(self.feature_selector)
        layout.addWidget(self.add_feature_button)
        self.main_layout.addLayout(layout)
        for name in self.default_features["names"]:
            self.features_combo_box.addItem(self.default_features["names"][name])
        self.features_combo_box.currentTextChanged.connect(self.set_input_type)
        self.set_input_type()

    def set_input_type(self):
        for type in self.default_features["types"]:
            if (
                self.default_features["names"][type]
                == self.features_combo_box.currentText()
            ):
                if self.default_features["types"][type] != "s":
                    self.feature_line_edit.setHidden(True)
                    self.feature_selector.setHidden(False)
                    self.feature_selector.clear()
                    for value in self.default_features["values"][type]:
                        self.feature_selector.addItem(
                            self.default_features["values"][type][value]
                        )
                else:
                    self.feature_line_edit.setHidden(False)
                    self.feature_selector.setHidden(True)

    def add_feature(self):
        # if self.feature_line_edit.isVisible():
        #     self.data[self.default_features["names"][self.feature_line_edit.text()]] = ""
        pass


class CustomTableModel(QAbstractTableModel):
    def __init__(self, data: dict, default_features: dict):
        super().__init__()
        self.features = data
        self.feature_keys = list(self.features.keys())
        self.default_features = default_features

    def rowCount(self, parent=QtCore.QModelIndex()):
        return len(self.features)

    def columnCount(self, parent=QtCore.QModelIndex()):
        return 2

    # noinspection PyMethodOverriding
    def headerData(self, section, orientation, role):
        if role == QtCore.Qt.DisplayRole and orientation == QtCore.Qt.Horizontal:
            if section == 0:
                return "Feature"
            else:
                return "Value"
        return None

    def flags(self, index):
        if index.column() == 1:
            return (
                QtCore.Qt.ItemIsEditable
                | QtCore.Qt.ItemIsEnabled
                | QtCore.Qt.ItemIsSelectable
            )
        else:
            return QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsSelectable

    def data(self, index, role=QtCore.Qt.DisplayRole):
        row = index.row()
        if row < 0 or row >= len(self.feature_keys):
            return None

        if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole:
            column = index.column()
            name = self.feature_keys[row]
            if column == 0:
                return self.default_features["names"].get(name, name)
            elif column == 1:
                feature_type = self._get_feature_type(name)
                value = self.features[name]
                if feature_type == "e":
                    return self.default_features["values"][name].get(value, value)
                elif feature_type in ("d", "i"):
                    return prettyprinter.print_feature(name, value, feature_type)
                else:
                    return value
        elif role == QtCore.Qt.TextAlignmentRole:
            column = index.column()
            if column == 0:
                return QtCore.Qt.AlignLeft + QtCore.Qt.AlignVCenter
            elif column == 1:
                return QtCore.Qt.AlignRight + QtCore.Qt.AlignVCenter

        return None

    # noinspection PyMethodOverriding
    def setData(self, index, value, role):
        if role == QtCore.Qt.EditRole:
            row = index.row()
            col = index.column()
            if col != 1:
                return False
            if row < 0 or row >= len(self.feature_keys):
                return False

            name = self.feature_keys[row]
            feature_type = self._get_feature_type(name)
            if isinstance(value, str):
                value = value.strip()

            if feature_type == "e":
                value = str(value).lower()
                if value not in self.default_features["values"][name]:
                    return False
            elif feature_type == "d":
                value = self._printable_to_value(name, value)
                value = float(value)
                if value <= 0:
                    return False
            elif feature_type == "i":
                value = self._printable_to_value(name, value)
                value = int(round(value))
                if value <= 0:
                    return False
            else:
                if len(value) <= 0:
                    return False
            self.features[name] = value
            return True
        return False

    @staticmethod
    def _printable_to_value(name, value):
        # noinspection PyBroadException
        try:
            value = prettyprinter.printable_to_value(
                prettyprinter.name_to_unit(name), value
            )
        except BaseException:
            value = 0
        return value

    def _get_feature_type(self, name):
        feature_type = self.default_features["types"].get(name, "s")
        return feature_type


class JsonWidget(QtWidgets.QDialog):
    def __init__(self, data):
        super().__init__()
        layout = QtWidgets.QVBoxLayout()
        text_edit = QtWidgets.QPlainTextEdit()
        text_edit.setWordWrapMode(QtGui.QTextOption.NoWrap)
        text_edit.setPlainText(f"{json.dumps(data, indent=2)}")
        text_edit.setReadOnly(True)
        layout.addWidget(text_edit)
        self.setLayout(layout)
        self.exec_()


class TaralloUploadDialog(QtWidgets.QDialog):
    signal = QtCore.pyqtSignal(bool, bool, str, name="event")

    def __init__(self, bulk_id: str = ""):
        super().__init__()
        uic.loadUi(PATH["TARALLOUPLOADDIALOG"], self)

        self.setWindowTitle("Set bulk identifier")
        self.bulkLineEdit = self.findChild(QtWidgets.QLineEdit, "bulkLineEdit")
        self.bulkLineEdit.setText(bulk_id)
        self.okButton = self.findChild(QtWidgets.QPushButton, "okButton")
        self.okButton.clicked.connect(self.ok_signal)
        self.cancelButton = self.findChild(QtWidgets.QPushButton, "cancelButton")
        self.cancelButton.clicked.connect(self.cancel_signal)
        self.overwriteCheckBox = self.findChild(
            QtWidgets.QCheckBox, "overwriteCheckBox"
        )

    def ok_signal(self):
        self.signal.emit(self.overwriteCheckBox.isChecked(), self.bulkLineEdit.text())
        self.close()

    def cancel_signal(self):
        self.close()


class Uploader(QtCore.QThread):
    successEvent = QtCore.pyqtSignal(str)
    failureEvent = QtCore.pyqtSignal(str, str)

    def __init__(
        self,
        data: list,
        tarallo_url: str,
        tarallo_token: str,
        bulk_identifier: str,
        overwrite: bool,
    ):
        super().__init__()
        self.data = data
        self.tarallo_url = tarallo_url
        self.tarallo_token = tarallo_token
        self.bulk_identifier = bulk_identifier
        self.overwrite = overwrite

    def run(self) -> None:
        try:
            tarallo = Tarallo.Tarallo(self.tarallo_url, self.tarallo_token)
            ver = tarallo.bulk_add(self.data, self.bulk_identifier, self.overwrite)
            if ver:
                # TODO: replace lollone with the actual code asd
                self.successEvent.emit(self.bulk_identifier)
            else:
                self.failureEvent.emit("cannot_upload", self.bulk_identifier)

        except NoInternetConnectionError:
            self.failureEvent.emit("cannot_reach", self.bulk_identifier)


def tarallo_success_dialog(url: str):
    dialog = QtWidgets.QMessageBox(
        QtWidgets.QMessageBox.Information,
        "Upload successful",
        "Upload successful! Now go to TARALLO and finish the job.",
    )
    std_width = (
        QtWidgets.QApplication.style()
        .standardIcon(QtWidgets.QStyle.SP_MessageBoxWarning)
        .availableSizes()[-1]
        .width()
    )
    dialog.setIconPixmap(
        QtGui.QPixmap("data/pear_emoji.png").scaledToWidth(
            std_width, QtCore.Qt.SmoothTransformation
        )
    )
    dialog.setStandardButtons(QtWidgets.QMessageBox.Ok)
    view_on_tarallo_button = dialog.addButton("View on TARALLO", dialog.ActionRole)
    dialog.exec_()
    if dialog.clickedButton() == view_on_tarallo_button:
        url = QtCore.QUrl(url)
        if not QtGui.QDesktopServices.openUrl(url):
            QtWidgets.QMessageBox.warning(
                dialog, "Cannot Open Url", f"Could not open url {url}"
            )
        return True
    return False


def main():
    # noinspection PyBroadException
    try:
        load_dotenv()
        tarallo_url = env["TARALLO_URL"]
        tarallo_token = env["TARALLO_TOKEN"]
        app = QtWidgets.QApplication(sys.argv)
        # This is EXTREMELY IMPORTANT, DON'T TACH [sic], DO NOT REMOVE IT EVER
        # noinspection PyUnusedLocal
        window = Ui(app, tarallo_url, tarallo_token)
        app.exec_()

    except KeyboardInterrupt:
        print("KeyboardInterrupt")

    except BaseException:
        print(traceback.print_exc(file=sys.stdout))


if __name__ == "__main__":
    main()
