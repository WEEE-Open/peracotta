#!/usr/bin/env python3
from typing import Optional
from urllib.error import URLError
from PyQt5 import uic, QtWidgets, QtCore, QtGui
from PyQt5.QtCore import QAbstractTableModel
from collections import defaultdict
from os.path import expanduser
from pytarallo import Tarallo
from pytarallo.Errors import NoInternetConnectionError
from dotenv import load_dotenv
from os import environ as env
import shutil
import time
import os
import urllib.parse
import urllib.request
import sys
import traceback
import json
import prettyprinter
import peracommon

# TODO: peracruda/58 call parsers
# TODO: peracruda/63 set owner to everything
# TODO: peracruda/66 split_products returns the list of product
# TODO: peracommon.unmake_tree if JSON loaded
# TODO: peracommon.make_tree before upload


VERSION = "2.0"

URL = {
    "website": "https://weeeopen.polito.it",
    "source_code": "https://github.com/WEEE-Open/peracotta",
}

PATH = {
    "UI": "assets/interface.ui",
    "TARALLOUPLOADDIALOG": "assets/uploadTaralloDialog.ui",
    "JSON": "copy_this_to_tarallo.json",
    "FEATURES": "features.json",
    "THEMES": "assets/themes/",
    "TMP_FILES": "tmp/",
}

ICON = {
    "case": "assets/toolbox/case.png",
    "ram": "assets/toolbox/ram.png",
    "cpu": "assets/toolbox/cpu.png",
    "graphics-card": "assets/toolbox/gpu.png",
    "odd": "assets/toolbox/odd.png",
    "hard disk": "assets/toolbox/hard disk.png",
    "motherboard": "assets/toolbox/motherboard.png",
    "wifi-card": "assets/toolbox/wifi-card.png",
    "psu": "assets/toolbox/psu.png",
    "monitor": "assets/toolbox/monitor.png",
    "keyboard": "assets/toolbox/keyboard.png",
    "mouse": "assets/toolbox/mouse.png",
}

DEFAULT_PROGRESS_BAR_STYLE = (
    "QStatusBar::item {"
    "min-height: 12px;"
    "max-height: 12px;"
    "}"
    "QProgressBar {"
    "min-height: 14px;"
    "max-height: 14px;"
    "}"
    "QProgressBar::chunk {"
    "background-color: #00963A;"
    "width: 50px;"
    "}"
)


class Ui(QtWidgets.QMainWindow):
    def __init__(
        self,
        app: QtWidgets.QApplication,
        tarallo_url: str,
        tarallo_token: str,
        tarallo_auto_download: bool,
    ) -> None:
        super(Ui, self).__init__()
        uic.loadUi(PATH["UI"], self)
        self.app = app
        self.taralloDialog = None
        self.data = list(dict())
        self.tarallo_url = tarallo_url
        self.tarallo_token = tarallo_token
        self.useful_default_features = dict()
        self.encountered_types_count = defaultdict(lambda: 0)

        # self.useful_default_features must be set correctly, otherwise the GUI will fail to load
        try:
            self.load_features_file(tarallo_auto_download)
        except Exception as e:
            title = "Cannot download features"
            message = f"Failed to download features from TARALLO: {str(e)}"
            if self.useful_default_features == {}:
                QtWidgets.QMessageBox.critical(
                    self,
                    title,
                    message
                    + "\n\nPeracotta will now terminate.\nIf the problem persists, you can try peracruda instead.",
                )
                exit(1)
            else:
                QtWidgets.QMessageBox.warning(self, title, message)

        # Output toolbox
        self.outputWidget = self.findChild(QtWidgets.QWidget, "outputWidget")
        self.itemToolBox = ToolBoxWidget(
            self.data, self.useful_default_features, self.encountered_types_count
        )
        self.outputWidget.layout().addWidget(self.itemToolBox)

        # App settings
        self.settings = QtCore.QSettings("WEEE Open", "PERACOTTA")

        # Gpu location layout
        self.gpuGroupBox = self.findChild(QtWidgets.QGroupBox, "gpuGroupBox")

        # Radio buttons
        self.discreteRadioBtn = self.findChild(
            QtWidgets.QRadioButton, "discreteRadioBtn"
        )
        self.intCpuRadioBtn = self.findChild(QtWidgets.QRadioButton, "intCpuRadioBtn")
        self.intMoboRadioBtn = self.findChild(QtWidgets.QRadioButton, "intMoboRadioBtn")

        # Selectors area
        self.selectorsWidget = self.findChild(QtWidgets.QWidget, "selectorsWidget")
        self.selectorsScrollArea = self.findChild(
            QtWidgets.QScrollArea, "selectorsScrollArea"
        )

        self.addItemComboBox = self.findChild(QtWidgets.QComboBox, "addItemComboBox")
        self.addItemComboBox.addItem("Select Type --")
        for the_type in self.useful_default_features["values"]["type"]:
            tye_type_fancy = self.useful_default_features["values"]["type"][the_type]
            self.addItemComboBox.addItem(tye_type_fancy)
            if the_type in ICON:
                icon = QtGui.QIcon(ICON[the_type])
                self.addItemComboBox.setItemIcon(self.addItemComboBox.count() - 1, icon)
        self.addItemComboBox.currentTextChanged.connect(self.add_toolbox_item)
        self.addItemComboBox.wheelEvent = lambda stop_wheel_event: None

        # select/deselect all buttons
        self.selectAllBtn = self.findChild(QtWidgets.QPushButton, "selectBtn")
        self.selectAllBtn.clicked.connect(self.select_all_checkboxes)
        self.deselectAllBtn = self.findChild(QtWidgets.QPushButton, "deselectBtn")
        self.deselectAllBtn.clicked.connect(self.deselect_all_checkboxes)

        # Owner line edit
        self.ownerLineEdit = self.findChild(QtWidgets.QLineEdit, "ownerLineEdit")

        # Generate data button
        self.generateBtn = self.findChild(QtWidgets.QPushButton, "generateBtn")
        self.generateBtn.clicked.connect(self.generate)

        # Reset selectors button
        self.resetBtn = self.findChild(QtWidgets.QPushButton, "resetBtn")
        self.resetBtn.clicked.connect(self.reset_setup_group)

        # Save JSON button
        self.saveJsonBtn = self.findChild(QtWidgets.QPushButton, "saveJsonBtn")
        self.saveJsonBtn.clicked.connect(self.save_json)

        # Upload to tarallo button
        self.uploadBtn = self.findChild(QtWidgets.QPushButton, "uploadBtn")
        self.uploadBtn.clicked.connect(self.tarallo_dialog)

        # File actions
        self.actionOpen = self.findChild(QtWidgets.QAction, "actionOpen")
        self.actionOpen.triggered.connect(self.open_json)
        self.actionOpenLastJson = self.findChild(
            QtWidgets.QAction, "actionOpenLastJson"
        )
        self.actionOpenLastJson.triggered.connect(self.open_latest_json)
        self.actionOpenJson = self.findChild(QtWidgets.QAction, "actionOpenJson")
        self.actionOpenJson.triggered.connect(self.show_json)
        self.actionLoadRawFiles = self.findChild(
            QtWidgets.QAction, "actionLoadRawFiles"
        )
        self.actionLoadRawFiles.triggered.connect(self.load_raw_files)
        self.actionExit = self.findChild(QtWidgets.QAction, "actionExit")
        self.actionExit.triggered.connect(self.close)

        # Options actions
        self.menuTheme = self.findChild(QtWidgets.QMenu, "menuTheme")
        action = list()
        action.append(self.menuTheme.addAction("Default"))
        action[-1].triggered.connect(lambda: self.set_theme("default"))
        for theme_file in os.listdir(PATH["THEMES"]):
            theme = theme_file.rstrip(".css")
            action.append(self.menuTheme.addAction(theme.title()))
            action[-1].triggered.connect((lambda t: lambda: self.set_theme(t))(theme))

        # Help actions
        self.actionAboutUs = self.findChild(QtWidgets.QAction, "actionAboutUs")
        self.actionAboutUs.triggered.connect(self.open_website)
        self.actionSourceCode = self.findChild(QtWidgets.QAction, "actionSourceCode")
        self.actionSourceCode.triggered.connect(self.open_source_code)
        self.actionVersion = self.findChild(QtWidgets.QAction, "actionVersion")
        self.actionVersion.triggered.connect(self.show_version)

        # Status bar widgets
        self.progressBar = QtWidgets.QProgressBar()
        self.statusBar().addPermanentWidget(self.progressBar)
        self.progressBar.hide()
        # self.statusBar().setStyleSheet(DEFAULT_PROGRESS_BAR_STYLE)

        # Setup peracotta QThread
        self.peracotta = Peracotta(
            self,
            self.discreteRadioBtn,
            self.intCpuRadioBtn,
            self.ownerLineEdit,
            PATH["TMP_FILES"],
        )
        self.peracotta.updateEvent.connect(self.peracotta_results)
        self.peracotta.startEvent.connect(self.show_busy_progress_bar)

        self.show()
        self.setup()

    def setup(self):
        self.reset_toolbox()

        layout = self.selectorsWidget.layout()
        niy = peracommon.ParserComponents.not_implemented_yet()
        for item in peracommon.ParserComponents:
            checkbox = QtWidgets.QCheckBox(item.value)
            if item in niy:
                checkbox.setEnabled(False)
            layout.addWidget(checkbox)
        self.reset_setup_group()

    @staticmethod
    def _backup_features_json() -> bool:
        here = os.path.dirname(os.path.realpath(__file__))
        try:
            shutil.copy2(
                os.path.join(here, "features.json"),
                os.path.join(here, "features.json.bak"),
            )
        except FileNotFoundError:
            return False
        return True

    @staticmethod
    def _restore_features_json() -> bool:
        here = os.path.dirname(os.path.realpath(__file__))
        try:
            shutil.move(
                os.path.join(here, "features.json.bak"),
                os.path.join(here, "features.json"),
            )
        except FileNotFoundError:
            return False
        return True

    def load_features_file(self, auto_update: bool):
        self.useful_default_features = {}
        has_file = False
        error = None

        try:
            mtime = os.path.getmtime(PATH["FEATURES"])
            has_file = True
        except FileNotFoundError:
            mtime = 0

        if auto_update and time.time() - mtime > 60 * 60 * 12:
            # TODO: etag/if-modified-since
            request = urllib.request.Request(url=f"{self.tarallo_url}/features.json")
            request.add_header("User-Agent", "peracotta")
            request.add_header("Accept", "application/json")
            self._backup_features_json()
            # noinspection PyBroadException
            try:
                with urllib.request.urlopen(request) as response:
                    with open("features.json", "w") as out:
                        shutil.copyfileobj(response, out)
                        has_file = True
            except URLError as e:
                if hasattr(e, "reason"):
                    error = "Connection error: " + str(e.reason)
                elif hasattr(e, "code"):
                    error = "Server error: " + str(e.code)
            except BaseException as e:
                error = "Some error: " + str(e)

            if error:
                has_file = self._restore_features_json()

        if has_file:
            self._parse_features_file()

        if error:
            raise Exception(error)
        if not has_file and not auto_update:
            raise Exception(
                "features.json file not present and automatic download is disabled"
            )

    def _parse_features_file(self):
        with open(PATH["FEATURES"], "r") as file:
            default_feature_names = {}
            default_feature_types = {}
            default_feature_values = {}
            default_features = json.load(file)
            for group in default_features["features"]:
                for feature in default_features["features"][group]:
                    name = feature["name"]
                    default_feature_names[name] = feature["printableName"]
                    default_feature_types[name] = feature["type"]
                    if "values" in feature:
                        default_feature_values[name] = feature["values"]
            self.useful_default_features = {
                "names": default_feature_names,
                "types": default_feature_types,
                "values": default_feature_values,
            }

    # gui utilities
    def set_toolbox(self):
        self.types_count()

    def reset_toolbox(self):
        for idx in range(self.itemToolBox.count()):
            self.itemToolBox.removeItem(0)

    def open_url(self, url_type: str):
        url = QtCore.QUrl(url_type)
        if not QtGui.QDesktopServices.openUrl(url):
            QtWidgets.QMessageBox.warning(
                self, "Cannot Open Url", f"Could not open url {url_type}"
            )

    def set_theme(self, theme: str):
        if theme == "default":
            self.app.setStyleSheet("")
            return
        with open(f"{PATH['THEMES']}{theme}.css", "r") as file:
            self.app.setStyleSheet(file.read())

    def show_busy_progress_bar(self):
        self.progressBar.setRange(0, 0)
        self.progressBar.show()

    def select_all_checkboxes(self):
        for checkbox in self.selectorsWidget.findChildren(QtWidgets.QCheckBox):
            checkbox.setChecked(True)

    def deselect_all_checkboxes(self):
        for checkbox in self.selectorsWidget.findChildren(QtWidgets.QCheckBox):
            checkbox.setChecked(False)

    # tarallo utilities
    def upload_to_tarallo(self, checkbox: bool, bulk_id=None):
        if bulk_id == "":
            bulk_id = None
        uploader = Uploader(
            self.data, self.tarallo_url, self.tarallo_token, bulk_id, checkbox
        )
        uploader.successEvent.connect(self.tarallo_success)
        uploader.failureEvent.connect(self.tarallo_failure)

    def tarallo_success(self, code: str):
        url = f"{self.tarallo_url}/bulk/import#{urllib.parse.quote(code)}"
        tarallo_success_dialog(url)

    def tarallo_failure(self, case: str, bulk_id: str):
        if case == "cannot_upload":
            QtWidgets.QMessageBox.warning(
                self,
                "Cannot upload to T.A.R.A.L.L.O.",
                "Cannot upload, try to change the bulk identifier or check the overwrite checkbox.",
            )
            self.tarallo_dialog(bulk_id)
        elif case == "cannot_reach":
            QtWidgets.QMessageBox.warning(
                self,
                "Unable to reach the T.A.R.A.L.L.O.",
                "Please connect this PC to the Internet and try again.",
            )

    # buttons functions
    def reset_setup_group(self):
        # reset gpu location
        for radioBtn in self.gpuGroupBox.findChildren(QtWidgets.QRadioButton):
            radioBtn.setAutoExclusive(False)
            radioBtn.setChecked(False)
            radioBtn.setAutoExclusive(True)

        # reset checkboxes
        defaults = set(peracommon.ParserComponents.all_names()) - {
            peracommon.ParserComponents.MONITOR.value,
            peracommon.ParserComponents.INPUT.value,
        }

        for checkbox in self.selectorsWidget.findChildren(QtWidgets.QCheckBox):
            if checkbox.text() in defaults and checkbox.isEnabled():
                checkbox.setChecked(True)
            else:
                checkbox.setChecked(False)

        # reset owner
        self.ownerLineEdit.clear()

    def generate(self):
        def warning():
            QtWidgets.QMessageBox.warning(
                self, "Warning", "Please, select one of the GPU locations to proceed."
            )

        if not (
            self.discreteRadioBtn.isChecked()
            or self.intCpuRadioBtn.isChecked()
            or self.intMoboRadioBtn.isChecked()
        ):
            warning()
            return

        sudo_passwd, ok = QtWidgets.QInputDialog.getText(
            self,
            "Insert root password",
            "Insert root password:",
            QtWidgets.QLineEdit.Password,
        )
        if ok:
            self.peracotta.sudo_passwd = sudo_passwd
        else:
            return
        self.peracotta.generate_files = True
        self.peracotta.set_filters(self.selectorsWidget)
        self.peracotta.start()
        self.reset_toolbox()

    def save_json(self):
        if self.data is None:
            QtWidgets.QMessageBox.warning(
                self, "Warning", "There is nothing to be saved"
            )
            return
        the_dir = QtWidgets.QFileDialog.getSaveFileName(
            self,
            "Save Peracotta JSON",
            f"{expanduser('~')}",
            "JSON (*.json);;Text file (*.txt);;All Files (*)",
        )
        if the_dir[0] == "":
            return
        with open(the_dir[0], "w") as file:
            file.write(f"{json.dumps(self.data)}")
            file.flush()
            file.close()

    def tarallo_dialog(self, bulk_id=str()):
        if self.data is None:
            QtWidgets.QMessageBox.warning(
                self, "Warning", "There is nothing to be uploaded"
            )
            return
        if not bulk_id:
            bulk_id = ""
        self.taralloDialog = TaralloUploadDialog(bulk_id)
        self.taralloDialog.signal.connect(self.upload_to_tarallo)

    def add_toolbox_item(self):
        if self.addItemComboBox.currentIndex() == 0:
            return
        else:
            type = self.addItemComboBox.currentText().lower()
            if not self.encountered_types_count[type]:
                counter = ""
            else:
                counter = f" #{self.encountered_types_count[type] + 1}"
            self.encountered_types_count[type] += 1

            data = {"type": self.addItemComboBox.currentText().lower()}
            self.itemToolBox.addItem(
                ToolBoxItem(data, self.useful_default_features),
                f"{self.print_type_cool(type)}{counter}",
            )
            if type in ICON:
                icon = QtGui.QIcon(ICON[type])
                self.itemToolBox.setItemIcon(self.itemToolBox.count() - 1, icon)
            if self.data is None:
                self.data = []
            self.data.append({})
            self.addItemComboBox.setCurrentIndex(0)

    # menu actions
    def open_json(self, path: str = ""):
        self.itemToolBox.clear()

        if not path:
            the_dir = QtWidgets.QFileDialog.getOpenFileName(
                self,
                "Open JSON",
                f"{expanduser('~')}",
                f"JSON (*.json);;All Files (*)",
            )
            path = the_dir[0]
        if path == "":
            self.data = None
            return
        with open(path, "r") as file:
            self.data = json.load(file)

        self.data = peracommon.unmake_tree(self.data)
        self.settings.setValue("latest_json", path)
        self.itemToolBox.load_items(self.data)

    def open_latest_json(self):
        for key in self.settings.childKeys():
            if "latest_json" in key:
                self.open_json(self.settings.value("latest_json"))

    def load_raw_files(self):
        print("Loading raw files...")

    def show_json(self):
        if self.data is None:
            return
        JsonWidget(self.data)

    def open_website(self):
        self.open_url(URL["website"])

    def open_source_code(self):
        self.open_url(URL["source_code"])

    def show_version(self):
        QtWidgets.QMessageBox.about(self, "Version", f"Peracotta v{VERSION}")

    # multithread
    def peracotta_results(self, data: list):
        self.progressBar.setRange(0, 1)  # disable statusBar's progressBar
        self.progressBar.hide()
        self.data = data
        self.set_toolbox()
        # checks for wanted items
        # for checkbox in self.selectorsWidget.findChildren(QtWidgets.QCheckBox):
        #     self.selectors.update({checkbox.text().lower(): checkbox.isChecked()})

        # toolbox fill

    # close event
    def closeEvent(self, a0: QtGui.QCloseEvent) -> None:
        if self.peracotta.isRunning():
            self.peracotta.terminate()


class Peracotta(QtCore.QThread):
    updateEvent = QtCore.pyqtSignal(list, name="update")
    startEvent = QtCore.pyqtSignal()

    def __init__(
        self,
        main_window: QtWidgets.QMainWindow,
        discrete_radio_btn: QtWidgets.QRadioButton,
        int_cpu_radio_btn: QtWidgets.QRadioButton,
        owner_line_edit: QtWidgets.QLineEdit,
        generated_files_path: str,
    ):
        super().__init__()
        self.main_window = main_window
        self.discrete_radio_btn = discrete_radio_btn
        self.int_cpu_radio_btn = int_cpu_radio_btn
        self.gpu_location = None
        self.owner = owner_line_edit.text()
        self.generated_files_path = generated_files_path
        self.generate_files = None

        self.filters = []
        self.the_dir = None
        self.set_default_values()
        self.sudo_passwd = None

        self.is_running = False

    def run(self) -> None:
        self.is_running = True
        self.startEvent.emit()
        self.gpu_location = (
            peracommon.GpuLocation.DISCRETE
            if self.discrete_radio_btn.isChecked()
            else peracommon.GpuLocation.CPU
            if self.int_cpu_radio_btn.isChecked()
            else peracommon.GpuLocation.MOTHERBOARD
        )
        result = []
        if self.generate_files:
            if sys.platform == "win32":
                from scripts.get_windows_specs import generate_win_files

                generate_win_files()
                self.process_win_files()
            else:
                message = peracommon.check_required_files(
                    self.generated_files_path, is_gui=True
                )
                if message != "":
                    QtWidgets.QMessageBox.critical(self.main_window, "Error", message)
                self.generated_files_path = peracommon.generate_files(
                    self.the_dir, self.sudo_passwd
                )
                if self.generated_files_path is None:
                    print("Wrong root password. Terminating peracotta...")
                    return
                result = peracommon.call_parsers(
                    self.generated_files_path,
                    set(self.filters),
                    self.gpu_location,
                    False,
                )
                if self.owner != "":
                    result = peracommon.add_owner(result, self.owner)
                result = peracommon.split_products(result)
        self.updateEvent.emit(result)
        self.set_default_values()

    def set_default_values(self):
        self.filters = []
        self.generate_files = False
        self.the_dir = "tmp"
        self.is_running = True
        self.sudo_passwd = None

    def process_files(self):
        pass

    def process_win_files(self):
        pass

    def set_filters(self, widget: QtWidgets.QWidget):
        for checkbox in widget.findChildren(QtWidgets.QCheckBox):
            if checkbox.isChecked():
                self.filters.append(peracommon.ParserComponents(checkbox.text()))


class ItemEnumDelegate(QtWidgets.QStyledItemDelegate):
    # class ItemEnumAlignDelegate(QtWidgets.QStyledItemDelegate):
    #     def initStyleOption(self, option, index):
    #         super().initStyleOption(option, index)
    #         option.displayAlignment = QtCore.Qt.AlignLeft

    def createEditor(self, parent, option, index):
        the_type = str(index.model().data(index, QtCore.Qt.UserRole))
        if the_type == "e":
            editor = QtWidgets.QComboBox(parent)
            editor.currentTextChanged.connect(self.handle_editor_change)
            editor.setEditable(True)
            return editor
        else:
            return super().createEditor(parent, option, index)

    def setEditorData(self, editor, index):
        model: CustomTableModel = index.model()
        if isinstance(editor, QtWidgets.QComboBox):
            values = model.row_all_enum_values_for_editor(index.row())
            current = model.row_current_enum_value_for_editor(index.row())
            if values and current:
                # editor.setItemDelegate(self.ItemEnumAlignDelegate(editor))
                for k, v in values.items():
                    editor.addItem(v, k)
                    i = editor.count() - 1
                    if current == k:
                        editor.setCurrentIndex(i)
        else:
            return super().setEditorData(editor, index)

    def setModelData(self, editor, model, index):
        if isinstance(editor, QtWidgets.QComboBox):
            model.setData(index, editor.currentData(), QtCore.Qt.EditRole)
        else:
            return super().setModelData(editor, model, index)

    def handle_editor_change(self):
        editor = self.sender()
        self.commitData.emit(editor)
        self.closeEditor.emit(editor)


class CustomTableView(QtWidgets.QTableView):
    def __init__(self):
        super().__init__()
        self.setItemDelegateForColumn(1, ItemEnumDelegate())

    def minimumSizeHint(self) -> QtCore.QSize:
        default_size = super().minimumSizeHint()

        frame = self.frameWidth() * 2

        header = self.verticalHeader().sizeHint().height()
        rows = self.verticalHeader().length()
        h = header + rows + frame
        # print(f"{header} + {rows} + {frame} = {h} > {default_size.height()}")

        return QtCore.QSize(default_size.width(), h)

    def contextMenuEvent(self, event: QtGui.QContextMenuEvent) -> None:
        self.menu = QtWidgets.QMenu(self)
        remove_action = QtWidgets.QAction("Remove feature", self)
        remove_action.triggered.connect(self.remove_row)
        self.menu.addAction(remove_action)
        self.menu.popup(QtGui.QCursor.pos())

    def remove_row(self):
        print(f"{self.selectedIndexes()[1].row()}")
        print(f"{self.selectedIndexes()[1].parent()}")
        self.model().removeRow(
            self.selectedIndexes()[1].row(), self.selectedIndexes()[1].parent()
        )


class ToolBoxItem(QtWidgets.QWidget):
    def __init__(self, data: dict, default_features: dict):
        super().__init__()
        self.default_features = default_features

        self.main_layout = QtWidgets.QVBoxLayout()
        self.table = CustomTableView()
        self.features_combo_box = QtWidgets.QComboBox()
        self.feature_line_edit = QtWidgets.QLineEdit()
        self.feature_selector = QtWidgets.QComboBox()
        self.add_feature_button = QtWidgets.QPushButton("Add")
        self.add_feature_button.clicked.connect(self.add_feature)

        # setup
        self.table_setup(data, default_features)
        self.feature_adder(data["type"])
        self.setLayout(self.main_layout)

    def table_setup(self, data: dict, default_features: dict):
        self.table.verticalHeader().hide()
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.setModel(CustomTableModel(data, default_features))
        self.table.setShowGrid(False)
        self.table.setAlternatingRowColors(True)
        self.table.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.table.verticalScrollBar().hide()
        self.table.verticalScrollBar().resize(0, 0)
        self.main_layout.addWidget(self.table)
        self.table.resizeColumnsToContents()
        self.table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)

    def feature_adder(self, type: str):
        layout = QtWidgets.QHBoxLayout()
        layout.addWidget(self.features_combo_box)
        layout.addWidget(self.feature_line_edit)
        layout.addWidget(self.feature_selector)
        layout.addWidget(self.add_feature_button)
        self.main_layout.addLayout(layout)
        for name in self.default_features["names"]:
            self.features_combo_box.addItem(self.default_features["names"][name])
        self.features_combo_box.currentTextChanged.connect(self.set_input_type)
        self.set_input_type()

    def set_input_type(self):
        for type in self.default_features["types"]:
            if (
                self.default_features["names"][type]
                == self.features_combo_box.currentText()
            ):
                if self.default_features["types"][type] == "e":
                    self.feature_line_edit.setHidden(True)
                    self.feature_selector.setHidden(False)
                    self.feature_selector.clear()
                    for value in self.default_features["values"][type]:
                        self.feature_selector.addItem(
                            self.default_features["values"][type][value]
                        )
                else:
                    self.feature_line_edit.setHidden(False)
                    self.feature_selector.setHidden(True)

    def add_feature(self):
        # if self.feature_line_edit.isVisible():
        #     self.data[self.default_features["names"][self.feature_line_edit.text()]] = ""
        pass

    def remove_feature(self):
        print(f"removing row {self.table.selectedIndexes()}")


class ToolBoxWidget(QtWidgets.QToolBox):
    def __init__(
        self, data: list[dict], default_features: dict, encountered_types_count: dict
    ):
        super().__init__()
        self.clear()
        self.data = data
        self.default_features = default_features
        self.encountered_types_count = encountered_types_count

        # variables
        self.encountered_types_current_count = defaultdict(lambda: 0)

    def clear(self):
        for idx in range(self.count()):
            self.removeItem(0)

    def load_items(self, data: list[dict]):
        if data:
            self.data = data
        self.types_count()
        for entry in self.data:
            if entry["type"] != "I":
                continue
            counter = ""
            type = entry["features"]["type"]
            if self.encountered_types_count[type] > 1:
                self.encountered_types_current_count[type] += 1
                counter = f" #{self.encountered_types_current_count[type]}"
            self.addItem(
                ToolBoxItem(entry["features"], self.default_features),
                f"{self.print_type_cool(type)}{counter}",
            )
            if type in ICON:
                icon = QtGui.QIcon(ICON[type])
                self.setItemIcon(self.count() - 1, icon)

            self.set_context_menu()

        # remove scroll in toolbox's scrollAreas
        for scroll_area in self.findChildren(QtWidgets.QScrollArea):
            scroll_area.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
            scroll_area.verticalScrollBar().hide()
            scroll_area.verticalScrollBar().resize(0, 0)

    def set_context_menu(self):
        counter = 0
        for item in self.children():
            if type(item) == QtWidgets.QAbstractButton:
                item: QtWidgets.QAbstractButton
                item.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
                item.customContextMenuRequested.connect(self.show_menu)
                counter += 1

    def print_type_cool(self, the_type: str) -> str:
        if the_type in self.default_features["values"]["type"]:
            return self.default_features["values"]["type"][the_type]
        else:
            return the_type.title()

    def show_menu(self):
        button = self.sender()
        self.menu = QtWidgets.QMenu()
        remove_action = QtWidgets.QAction("Remove item", self)
        remove_action.triggered.connect(lambda: self.remove_item_from_toolbox(button))
        self.menu.addAction(remove_action)
        self.menu.popup(QtGui.QCursor.pos())

    def minimumSizeHint(self) -> QtCore.QSize:
        h = 0
        for child in self.children():
            if isinstance(child, QtWidgets.QScrollArea):
                if child.isHidden():
                    h += child.minimumSizeHint().height()
                else:
                    h += child.sizeHint().height()
            elif isinstance(child, QtWidgets.QWidget):
                # print(f"{child}: {child.sizeHint().height()} vs {child.minimumSizeHint().height()}")
                # Buttons and anything else
                h += child.sizeHint().height()
        old = super().minimumSizeHint()
        if h > old.height():
            old.setHeight(h)
        return old

    def remove_item_from_toolbox(self, button):
        i = 0
        for item in self.children():
            if type(item) == QtWidgets.QAbstractButton:
                if item == button:
                    self.removeItem(i)
                    break
                else:
                    i += 1

    def removeItem(self, index: int) -> None:
        super().removeItem(index)
        i = 0
        for idx, entry in enumerate(self.data):
            if entry["type"] != "I":
                continue
            if index == i:
                del self.data[idx]
                break
            i += 1

    def types_count(self, data: list = None):
        if data is not None:
            self.data = data
        for entry in self.data:
            if entry["type"] != "I":
                continue
            the_type = entry["features"]["type"]
            self.encountered_types_count[the_type] += 1


class CustomTableModel(QAbstractTableModel):
    def __init__(self, data: dict, default_features: dict):
        super().__init__()
        self.features = data
        self.feature_keys = list(self.features.keys())
        self.default_features = default_features

    def rowCount(self, parent=QtCore.QModelIndex()):
        return len(self.features)

    def columnCount(self, parent=QtCore.QModelIndex()):
        return 2

    # noinspection PyMethodOverriding
    def headerData(self, section, orientation, role):
        if role == QtCore.Qt.DisplayRole and orientation == QtCore.Qt.Horizontal:
            if section == 0:
                return "Feature"
            else:
                return "Value"
        return None

    def flags(self, index):
        if index.column() == 1:
            return (
                QtCore.Qt.ItemIsEditable
                | QtCore.Qt.ItemIsEnabled
                | QtCore.Qt.ItemIsSelectable
            )
        else:
            return QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsSelectable

    def row_all_enum_values_for_editor(self, row: int) -> Optional[dict[str, str]]:
        if row < 0 or row >= len(self.feature_keys):
            return None

        name = self.feature_keys[row]
        feature_type = self._get_feature_type(name)
        if feature_type == "e":
            return self.default_features["values"][name]
        return None

    def row_current_enum_value_for_editor(self, row: int):
        if row < 0 or row >= len(self.feature_keys):
            return None

        name = self.feature_keys[row]
        return self.features.get(name)

    def data(self, index, role=QtCore.Qt.DisplayRole):
        row = index.row()
        if row < 0 or row >= len(self.feature_keys):
            return None

        if (
            role == QtCore.Qt.DisplayRole
            or role == QtCore.Qt.EditRole
            or role == QtCore.Qt.UserRole
        ):
            column = index.column()
            name = self.feature_keys[row]
            if column == 0:
                return self.default_features["names"].get(name, name)
            elif column == 1:
                feature_type = self._get_feature_type(name)
                if role == QtCore.Qt.UserRole:
                    return feature_type
                value = self.features[name]
                if feature_type == "e":
                    return self.default_features["values"][name].get(value, value)
                elif feature_type in ("d", "i"):
                    return prettyprinter.print_feature(name, value, feature_type)
                else:
                    return value
        elif role == QtCore.Qt.TextAlignmentRole:
            column = index.column()
            if column == 0:
                return QtCore.Qt.AlignLeft + QtCore.Qt.AlignVCenter
            elif column == 1:
                return QtCore.Qt.AlignLeft + QtCore.Qt.AlignVCenter

        return None

    # noinspection PyMethodOverriding
    def setData(self, index, value, role):
        if role == QtCore.Qt.EditRole:
            row = index.row()
            col = index.column()
            if col != 1:
                return False
            if row < 0 or row >= len(self.feature_keys):
                return False

            name = self.feature_keys[row]
            feature_type = self._get_feature_type(name)
            if isinstance(value, str):
                value = value.strip()

            if feature_type == "e":
                value = str(value).lower()
                if value not in self.default_features["values"][name]:
                    return False
            elif feature_type == "d":
                value = self._printable_to_value(name, value)
                value = float(value)
                if value <= 0:
                    return False
            elif feature_type == "i":
                value = self._printable_to_value(name, value)
                value = int(round(value))
                if value <= 0:
                    return False
            else:
                if len(value) <= 0:
                    return False
            self.features[name] = value
            return True
        return False

    def removeRow(self, row: int, parent: QtCore.QModelIndex() = ...) -> bool:
        self.beginRemoveRows(parent, row, row)
        del self.features[list(self.features)[row]]
        del self.feature_keys[row]
        self.endRemoveRows()
        return True

    @staticmethod
    def _printable_to_value(name, value):
        # noinspection PyBroadException
        try:
            value = prettyprinter.printable_to_value(
                prettyprinter.name_to_unit(name), value
            )
        except BaseException:
            value = 0
        return value

    def _get_feature_type(self, name):
        feature_type = self.default_features["types"].get(name, "s")
        return feature_type


class JsonWidget(QtWidgets.QDialog):
    def __init__(self, data):
        super().__init__()
        layout = QtWidgets.QVBoxLayout()
        text_edit = QtWidgets.QPlainTextEdit()
        text_edit.setWordWrapMode(QtGui.QTextOption.NoWrap)
        text_edit.setPlainText(f"{json.dumps(data, indent=2)}")
        text_edit.setReadOnly(True)
        layout.addWidget(text_edit)
        self.setLayout(layout)
        self.exec_()


class TaralloUploadDialog(QtWidgets.QDialog):
    signal = QtCore.pyqtSignal(bool, bool, str, name="event")

    def __init__(self, bulk_id: str = ""):
        super().__init__()
        uic.loadUi(PATH["TARALLOUPLOADDIALOG"], self)

        self.setWindowTitle("Set bulk identifier")
        self.bulkLineEdit = self.findChild(QtWidgets.QLineEdit, "bulkLineEdit")
        self.bulkLineEdit.setText(bulk_id)
        self.okButton = self.findChild(QtWidgets.QPushButton, "okButton")
        self.okButton.clicked.connect(self.ok_signal)
        self.cancelButton = self.findChild(QtWidgets.QPushButton, "cancelButton")
        self.cancelButton.clicked.connect(self.cancel_signal)
        self.overwriteCheckBox = self.findChild(
            QtWidgets.QCheckBox, "overwriteCheckBox"
        )

    def ok_signal(self):
        self.signal.emit(self.overwriteCheckBox.isChecked(), self.bulkLineEdit.text())
        self.close()

    def cancel_signal(self):
        self.close()


class Uploader(QtCore.QThread):
    successEvent = QtCore.pyqtSignal(str)
    failureEvent = QtCore.pyqtSignal(str, str)

    def __init__(
        self,
        data: list[dict],
        tarallo_url: str,
        tarallo_token: str,
        bulk_identifier: str,
        overwrite: bool,
    ):
        super().__init__()
        self.data = data
        self.tarallo_url = tarallo_url
        self.tarallo_token = tarallo_token
        self.bulk_identifier = bulk_identifier
        self.overwrite = overwrite

    def run(self) -> None:
        try:
            tarallo = Tarallo.Tarallo(self.tarallo_url, self.tarallo_token)
            ver = tarallo.bulk_add(self.data, self.bulk_identifier, self.overwrite)
            if ver:
                # TODO: replace lollone with the actual code asd
                self.successEvent.emit(self.bulk_identifier)
            else:
                self.failureEvent.emit("cannot_upload", self.bulk_identifier)

        except NoInternetConnectionError:
            self.failureEvent.emit("cannot_reach", self.bulk_identifier)


def tarallo_success_dialog(url: str):
    dialog = QtWidgets.QMessageBox(
        QtWidgets.QMessageBox.Information,
        "Upload successful",
        "Upload successful! Now go to TARALLO and finish the job.",
    )
    std_width = (
        QtWidgets.QApplication.style()
        .standardIcon(QtWidgets.QStyle.SP_MessageBoxWarning)
        .availableSizes()[-1]
        .width()
    )
    dialog.setIconPixmap(
        QtGui.QPixmap("data/pear_emoji.png").scaledToWidth(
            std_width, QtCore.Qt.SmoothTransformation
        )
    )
    dialog.setStandardButtons(QtWidgets.QMessageBox.Ok)
    view_on_tarallo_button = dialog.addButton("View on TARALLO", dialog.ActionRole)
    dialog.exec_()
    if dialog.clickedButton() == view_on_tarallo_button:
        url = QtCore.QUrl(url)
        if not QtGui.QDesktopServices.openUrl(url):
            QtWidgets.QMessageBox.warning(
                dialog, "Cannot Open Url", f"Could not open url {url}"
            )
        return True
    return False


def _env_to_bool(auto_download):
    if auto_download.lower() in ("1", "true", "t", "", "yes", "y"):
        auto_download = True
    else:
        auto_download = False
    return auto_download


def main():
    # noinspection PyBroadException
    try:
        load_dotenv()
        tarallo_url = env["TARALLO_URL"]
        tarallo_token = env["TARALLO_TOKEN"]
        auto_download = _env_to_bool(env.get("TARALLO_FEATURES_AUTO_DOWNLOAD", "1"))
        app = QtWidgets.QApplication(sys.argv)
        # This is EXTREMELY IMPORTANT, DON'T TACH [sic], DO NOT REMOVE IT EVER
        # noinspection PyUnusedLocal
        window = Ui(app, tarallo_url, tarallo_token, auto_download)
        app.exec_()

    except KeyboardInterrupt:
        print("KeyboardInterrupt")

    except BaseException:
        print(traceback.print_exc(file=sys.stdout))


if __name__ == "__main__":
    main()
