#!/usr/bin/env python3
import os

from PyQt5 import uic, QtWidgets, QtCore, QtGui, QtSql
from PyQt5.QtSql import QSqlDatabase
from PyQt5.QtCore import QAbstractTableModel
from collections import defaultdict
from os.path import expanduser
from pytarallo import Tarallo
from pytarallo.Errors import NoInternetConnectionError
from dotenv import load_dotenv
from os import environ as env
import urllib.parse
import sys
import traceback
import json
import prettyprinter
import peracommon

VERSION = "2.0"

URL = {
    "website": "https://weeeopen.polito.it",
    "source_code": "https://github.com/WEEE-Open/peracotta",
}

PATH = {
    "UI": "assets/interface.ui",
    "TARALLOUPLOADDIALOG": "assets/uploadTaralloDialog.ui",
    "JSON": "copy_this_to_tarallo.json",
    "FEATURES": "features.json",
    "THEMES": "assets/themes/",
}

ICON = {
    "case": "assets/toolbox/case.png",
    "ram": "assets/toolbox/ram.png",
    "cpu": "assets/toolbox/cpu.png",
    "gpu": "assets/toolbox/gpu.png",
    "odd": "assets/toolbox/odd.png",
    "hard disk": "assets/toolbox/hard disk.png",
    "motherboard": "assets/toolbox/motherboard.png",
    "wifi-card": "assets/toolbox/wifi-card.png",
    "psu": "assets/toolbox/psu.png",
    "monitor": "assets/toolbox/monitor.png",
    "keyboard": "assets/toolbox/keyboard.png",
    "mouse": "assets/toolbox/mouse.png",
}

DEFAULT_PROGRESS_BAR_STYLE = (
    "QStatusBar::item {"
    "min-height: 12px;"
    "max-height: 12px;"
    "}"
    "QProgressBar {"
    "min-height: 14px;"
    "max-height: 14px;"
    "}"
    "QProgressBar::chunk {"
    "background-color: #00963A;"
    "width: 50px;"
    "}"
)


class Ui(QtWidgets.QMainWindow):
    def __init__(
        self, app: QtWidgets.QApplication, tarallo_url: str, tarallo_token: str
    ) -> None:
        super(Ui, self).__init__()
        uic.loadUi(PATH["UI"], self)
        self.app = app
        self.taralloDialog = None
        self.data = None
        self.tarallo_url = tarallo_url
        self.tarallo_token = tarallo_token
        self.selectors = dict()
        self.useful_default_features = dict()
        self.encountered_types_count = defaultdict(lambda: 0)
        self.encountered_types_current_count = defaultdict(lambda: 0)

        # Output toolbox
        self.toolBox = self.findChild(QtWidgets.QToolBox, "toolBox")

        # Gpu location layout
        self.gpuGroupBox = self.findChild(QtWidgets.QGroupBox, "gpuGroupBox")

        # Radio buttons
        self.discreteRadioBtn = self.findChild(
            QtWidgets.QRadioButton, "discreteRadioBtn"
        )
        self.intCpuRadioBtn = self.findChild(QtWidgets.QRadioButton, "intCpuRadioBtn")

        # Selectors area
        self.selectorsWidget = self.findChild(QtWidgets.QWidget, "selectorsWidget")

        self.addItemComboBox = self.findChild(QtWidgets.QComboBox, "addItemComboBox")
        self.addItemComboBox.addItem("Select Type --")
        for checkbox in self.selectorsWidget.findChildren(QtWidgets.QCheckBox):
            self.addItemComboBox.addItem(checkbox.text())
            icon = QtGui.QIcon(ICON[checkbox.text().lower()])
            self.addItemComboBox.setItemIcon(self.addItemComboBox.count() - 1, icon)
        self.addItemComboBox.currentTextChanged.connect(self.add_toolbox_item)

        # Owner line edit
        self.ownerLineEdit = self.findChild(QtWidgets.QLineEdit, "ownerLineEdit")

        # Generate data button
        self.generateBtn = self.findChild(QtWidgets.QPushButton, "generateBtn")
        self.generateBtn.clicked.connect(self.generate)

        # Reset selectors button
        self.resetBtn = self.findChild(QtWidgets.QPushButton, "resetBtn")
        self.resetBtn.clicked.connect(self.reset_setup_group)

        # Save JSON button
        self.saveJsonBtn = self.findChild(QtWidgets.QPushButton, "saveJsonBtn")
        self.saveJsonBtn.clicked.connect(self.save_json)

        # Upload to tarallo button
        self.uploadBtn = self.findChild(QtWidgets.QPushButton, "uploadBtn")
        self.uploadBtn.clicked.connect(self.tarallo_dialog)

        # File actions
        self.actionOpen = self.findChild(QtWidgets.QAction, "actionOpen")
        self.actionOpen.triggered.connect(self.open_json)
        self.actionOpenJson = self.findChild(QtWidgets.QAction, "actionOpenJson")
        self.actionOpenJson.triggered.connect(self.show_json)
        self.actionExit = self.findChild(QtWidgets.QAction, "actionExit")
        self.actionExit.triggered.connect(self.close)

        # Options actions
        self.menuTheme = self.findChild(QtWidgets.QMenu, "menuTheme")
        action = self.menuTheme.addAction("Default")
        action.triggered.connect(lambda: self.set_theme("default"))
        for theme_file in os.listdir(PATH["THEMES"]):
            theme = theme_file.rstrip(".css")
            action = self.menuTheme.addAction(theme.title())
            action.triggered.connect(lambda: self.set_theme(theme))

        # Help actions
        self.actionAboutUs = self.findChild(QtWidgets.QAction, "actionAboutUs")
        self.actionAboutUs.triggered.connect(self.open_website)
        self.actionSourceCode = self.findChild(QtWidgets.QAction, "actionSourceCode")
        self.actionSourceCode.triggered.connect(self.open_source_code)
        self.actionVersion = self.findChild(QtWidgets.QAction, "actionVersion")
        self.actionVersion.triggered.connect(self.show_version)

        # Status bar widgets
        self.progressBar = QtWidgets.QProgressBar()
        self.statusBar().addPermanentWidget(self.progressBar)
        self.progressBar.hide()
        self.statusBar().setStyleSheet(DEFAULT_PROGRESS_BAR_STYLE)

        # Setup peracotta QThread
        self.peracotta = Peracotta(self.discreteRadioBtn, self.intCpuRadioBtn)
        self.peracotta.updateEvent.connect(self.peracotta_results)
        self.peracotta.startEvent.connect(self.show_busy_progress_bar)

        self.show()
        self.setup()

    def setup(self):
        try:
            self.reset_toolbox()
            with open(PATH["FEATURES"], "r") as file:
                default_feature_names = {}
                default_feature_types = {}
                default_feature_values = {}
                default_features = json.load(file)
                for group in default_features["features"]:
                    for feature in default_features["features"][group]:
                        name = feature["name"]
                        default_feature_names[name] = feature["printableName"]
                        default_feature_types[name] = feature["type"]
                        if "values" in feature:
                            default_feature_values[name] = feature["values"]
                self.useful_default_features = {
                    "names": default_feature_names,
                    "types": default_feature_types,
                    "values": default_feature_values,
                }

        except FileNotFoundError:
            print("DOWNLOAD THE THING FROM TARALLO NOW!")
            useful_default_features = {}

        if self.data is None:
            return

    # gui utilities
    def reset_toolbox(self):
        for idx in range(self.toolBox.count()):
            self.toolBox.removeItem(0)

    def open_url(self, url_type: str):
        url = QtCore.QUrl(url_type)
        if not QtGui.QDesktopServices.openUrl(url):
            QtWidgets.QMessageBox.warning(
                self, "Cannot Open Url", f"Could not open url {url_type}"
            )

    def set_theme(self, theme: str):
        if theme == "default":
            self.app.setStyleSheet("")
            return
        with open(f"{PATH['THEMES']}{theme}.css", "r") as file:
            self.app.setStyleSheet(file.read())

    @staticmethod
    def print_type_cool(the_type: str) -> str:
        if the_type in ("cpu", "ram", "hdd", "odd"):
            return the_type.upper()
        else:
            return the_type.title()

    def show_busy_progress_bar(self):
        self.progressBar.setRange(0, 0)
        self.progressBar.show()

    def type_count(self, data: list):
        for entry in data:
            if entry == {}:
                continue
            if "features" in entry and entry["features"] == {}:
                continue
            if "type" in entry and entry["type"] == "P":
                continue
            the_type = entry["features"]["type"]
            self.encountered_types_count[the_type] += 1

    def recursive_item_content_finder(self, data: list):
        for entry in data:
            if entry == {}:
                continue
            if "features" in entry and entry["features"] == {}:
                continue
            if "type" in entry and entry["type"] == "P":
                continue

            self.type_count(data)
            the_type = entry["features"]["type"]
            if not self.selectors[the_type]:
                continue
            counter = ""
            if self.encountered_types_count[the_type] > 1:
                self.encountered_types_current_count[the_type] += 1
                counter = f" #{self.encountered_types_current_count[the_type]}"
            self.toolBox.addItem(
                ToolBoxWidget(entry["features"], self.useful_default_features),
                f"{self.print_type_cool(the_type)}{counter}",
            )
            icon = QtGui.QIcon(ICON[the_type])
            self.toolBox.setItemIcon(self.toolBox.count() - 1, icon)

            if "contents" in entry:
                self.recursive_item_content_finder(entry["contents"])

    # tarallo utilities
    def upload_to_tarallo(self, checkbox: bool, bulk_id=None):
        if bulk_id == "":
            bulk_id = None
        uploader = Uploader(
            self.data, self.tarallo_url, self.tarallo_token, bulk_id, checkbox
        )
        uploader.successEvent.connect(self.tarallo_success)
        uploader.failureEvent.connect(self.tarallo_failure)

    def tarallo_success(self, code: str):
        url = f"{self.tarallo_url}/bulk/import#{urllib.parse.quote(code)}"
        tarallo_success_dialog(url)

    def tarallo_failure(self, case: str, bulk_id: str):
        if case == "cannot_upload":
            QtWidgets.QMessageBox.warning(
                self,
                "Cannot upload to T.A.R.A.L.L.O.",
                "Cannot upload, try to change the bulk identifier or check the overwrite checkbox.",
            )
            self.tarallo_dialog(bulk_id)
        elif case == "cannot_reach":
            QtWidgets.QMessageBox.warning(
                self,
                "Unable to reach the T.A.R.A.L.L.O.",
                "Please connect this PC to the Internet and try again.",
            )

    # buttons functions
    def reset_setup_group(self):
        # reset gpu location
        for radioBtn in self.gpuGroupBox.findChildren(QtWidgets.QRadioButton):
            radioBtn.setAutoExclusive(False)
            radioBtn.setChecked(False)
            radioBtn.setAutoExclusive(True)

        # reset checkboxes
        defaults = ["case", "motherboard", "cpu", "gpu", "ram", "hard disk", "odd"]
        for checkbox in self.selectorsWidget.findChildren(QtWidgets.QCheckBox):
            if checkbox.text().lower() in defaults:
                checkbox.setChecked(True)
            else:
                checkbox.setChecked(False)

        # reset owner
        self.ownerLineEdit.clear()

    def generate(self):
        self.peracotta.generate_files = True
        self.peracotta.start()
        self.reset_toolbox()

    def save_json(self):
        if self.data is None:
            QtWidgets.QMessageBox.warning(
                self, "Warning", "There is nothing to be saved"
            )
            return
        the_dir = QtWidgets.QFileDialog.getSaveFileName(
            self,
            "Save Peracotta JSON",
            f"{expanduser('~')}",
            "JSON (*.json);;Text file (*.txt);;All Files (*)",
        )
        if the_dir[0] == "":
            return
        with open(the_dir[0], "w") as file:
            file.write(f"{json.dumps(self.data)}")
            file.flush()
            file.close()

    def tarallo_dialog(self, bulk_id=str()):
        if self.data is None:
            QtWidgets.QMessageBox.warning(
                self, "Warning", "There is nothing to be uploaded"
            )
            return
        if not bulk_id:
            bulk_id = ""
        self.taralloDialog = TaralloUploadDialog(bulk_id)
        self.taralloDialog.signal.connect(self.upload_to_tarallo)

    def add_toolbox_item(self):
        if self.addItemComboBox.currentIndex() == 0:
            return
        else:
            type = self.addItemComboBox.currentText().lower()
            if not self.encountered_types_count[type]:
                counter = ""
            else:
                counter = f" #{self.encountered_types_count[type] + 1}"
            self.encountered_types_count[type] += 1

            data = {"type": self.addItemComboBox.currentText().lower()}
            self.toolBox.addItem(
                ToolBoxWidget(data, self.useful_default_features),
                f"{self.print_type_cool(type)}{counter}",
            )
            icon = QtGui.QIcon(ICON[type])
            self.toolBox.setItemIcon(self.toolBox.count() - 1, icon)
            if self.data is None:
                self.data = []
            self.data.append({})
            self.addItemComboBox.setCurrentIndex(0)

    # menu actions
    def open_json(self):
        self.reset_toolbox()
        the_dir = QtWidgets.QFileDialog.getOpenFileName(
            self,
            "title",
            f"{expanduser('~')}",
            f"JSON (*.json);;All Files (*)",
        )
        if the_dir[0] == "":
            self.data = None
            return
        with open(the_dir[0], "r") as file:
            self.data = json.load(file)

        self.peracotta_results(self.data)

    def show_json(self):
        if self.data is None:
            return
        JsonWidget(self.data)

    def open_website(self):
        self.open_url(URL["website"])

    def open_source_code(self):
        self.open_url(URL["source_code"])

    def show_version(self):
        QtWidgets.QMessageBox.about(self, "Version", f"Peracotta v{VERSION}")

    # multithread
    def peracotta_results(self, data: list):
        self.progressBar.setRange(0, 1)
        self.progressBar.hide()
        self.data = data

        # checks for wanted items
        for checkbox in self.selectorsWidget.findChildren(QtWidgets.QCheckBox):
            self.selectors.update({checkbox.text().lower(): checkbox.isChecked()})

        # toolbox fill
        self.recursive_item_content_finder(self.data)

    # close event
    def closeEvent(self, a0: QtGui.QCloseEvent) -> None:
        if self.peracotta.isRunning():
            self.peracotta.terminate()


class ToolBoxWidget(QtWidgets.QWidget):
    def __init__(self, data: dict, default_features: dict):
        super().__init__()
        self.default_features = default_features

        self.main_layout = QtWidgets.QVBoxLayout()
        self.table = QtWidgets.QTableView()
        self.features_combo_box = QtWidgets.QComboBox()
        self.feature_line_edit = QtWidgets.QLineEdit()
        self.feature_selector = QtWidgets.QComboBox()
        self.add_feature_button = QtWidgets.QPushButton("Add")

        # setup
        self.table_setup(data, default_features)
        self.feature_adder(data["type"])
        self.setLayout(self.main_layout)

    def table_setup(self, data: dict, default_features: dict):
        self.table.verticalHeader().hide()
        self.table.setModel(CustomTableModel(data, default_features))
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.setShowGrid(False)
        self.table.setAlternatingRowColors(True)
        self.main_layout.addWidget(self.table)

    def feature_adder(self, type: str):
        layout = QtWidgets.QHBoxLayout()
        layout.addWidget(self.features_combo_box)
        layout.addWidget(self.feature_line_edit)
        layout.addWidget(self.feature_selector)
        layout.addWidget(self.add_feature_button)
        self.main_layout.addLayout(layout)
        for name in self.default_features["names"]:
            self.features_combo_box.addItem(self.default_features["names"][name])
        self.features_combo_box.currentTextChanged.connect(self.set_input_type)
        self.set_input_type()

    def set_input_type(self):
        for type in self.default_features["types"]:
            if (
                self.default_features["names"][type]
                == self.features_combo_box.currentText()
            ):
                if self.default_features["types"][type] != "s":
                    self.feature_line_edit.setHidden(True)
                    self.feature_selector.setHidden(False)
                    self.feature_selector.clear()
                    for value in self.default_features["values"][type]:
                        self.feature_selector.addItem(
                            self.default_features["values"][type][value]
                        )
                else:
                    self.feature_line_edit.setHidden(False)
                    self.feature_selector.setHidden(True)


class CustomTableModel(QAbstractTableModel):
    def __init__(self, data: dict, default_features: dict):
        super().__init__()
        self.features = data
        self.feature_keys = list(self.features.keys())
        self.default_features = default_features

    def rowCount(self, parent=QtCore.QModelIndex()):
        return len(self.features)

    def columnCount(self, parent=QtCore.QModelIndex()):
        return 2

    # noinspection PyMethodOverriding
    def headerData(self, section, orientation, role):
        if role == QtCore.Qt.DisplayRole and orientation == QtCore.Qt.Horizontal:
            if section == 0:
                return "Feature"
            else:
                return "Value"
        return None

    def flags(self, index):
        if index.column() == 1:
            return (
                QtCore.Qt.ItemIsEditable
                | QtCore.Qt.ItemIsEnabled
                | QtCore.Qt.ItemIsSelectable
            )
        else:
            return QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsSelectable

    def data(self, index, role=QtCore.Qt.DisplayRole):
        row = index.row()
        if row < 0 or row >= len(self.feature_keys):
            return None

        if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole:
            column = index.column()
            name = self.feature_keys[row]
            if column == 0:
                return self.default_features["names"].get(name, name)
            elif column == 1:
                feature_type = self._get_feature_type(name)
                value = self.features[name]
                if feature_type == "e":
                    return self.default_features["values"][name].get(value, value)
                elif feature_type in ("d", "i"):
                    return prettyprinter.print_feature(name, value, feature_type)
                else:
                    return value
        elif role == QtCore.Qt.TextAlignmentRole:
            column = index.column()
            if column == 0:
                return QtCore.Qt.AlignLeft + QtCore.Qt.AlignVCenter
            elif column == 1:
                return QtCore.Qt.AlignRight + QtCore.Qt.AlignVCenter

        return None

    # noinspection PyMethodOverriding
    def setData(self, index, value, role):
        if role == QtCore.Qt.EditRole:
            row = index.row()
            col = index.column()
            if col != 1:
                return False
            if row < 0 or row >= len(self.feature_keys):
                return False

            name = self.feature_keys[row]
            feature_type = self._get_feature_type(name)
            if isinstance(value, str):
                value = value.strip()

            if feature_type == "e":
                value = str(value).lower()
                if value not in self.default_features["values"][name]:
                    return False
            elif feature_type == "d":
                value = self._printable_to_value(name, value)
                value = float(value)
                if value <= 0:
                    return False
            elif feature_type == "i":
                value = self._printable_to_value(name, value)
                value = int(round(value))
                if value <= 0:
                    return False
            else:
                if len(value) <= 0:
                    return False
            self.features[name] = value
            return True
        return False

    @staticmethod
    def _printable_to_value(name, value):
        # noinspection PyBroadException
        try:
            value = prettyprinter.printable_to_value(
                prettyprinter.name_to_unit(name), value
            )
        except BaseException:
            value = 0
        return value

    def _get_feature_type(self, name):
        feature_type = self.default_features["types"].get(name, "s")
        return feature_type


class JsonWidget(QtWidgets.QDialog):
    def __init__(self, data):
        super().__init__()
        layout = QtWidgets.QVBoxLayout()
        text_edit = QtWidgets.QPlainTextEdit()
        text_edit.setWordWrapMode(QtGui.QTextOption.NoWrap)
        text_edit.setPlainText(f"{json.dumps(data, indent=2)}")
        text_edit.setReadOnly(True)
        layout.addWidget(text_edit)
        self.setLayout(layout)
        self.exec_()


class TaralloUploadDialog(QtWidgets.QDialog):
    signal = QtCore.pyqtSignal(bool, bool, str, name="event")

    def __init__(self, bulk_id: str = ""):
        super().__init__()
        uic.loadUi(PATH["TARALLOUPLOADDIALOG"], self)

        self.setWindowTitle("Set bulk identifier")
        self.bulkLineEdit = self.findChild(QtWidgets.QLineEdit, "bulkLineEdit")
        self.bulkLineEdit.setText(bulk_id)
        self.okButton = self.findChild(QtWidgets.QPushButton, "okButton")
        self.okButton.clicked.connect(self.ok_signal)
        self.cancelButton = self.findChild(QtWidgets.QPushButton, "cancelButton")
        self.cancelButton.clicked.connect(self.cancel_signal)
        self.overwriteCheckBox = self.findChild(
            QtWidgets.QCheckBox, "overwriteCheckBox"
        )

    def ok_signal(self):
        self.signal.emit(self.overwriteCheckBox.isChecked(), self.bulkLineEdit.text())
        self.close()

    def cancel_signal(self):
        self.close()


class Peracotta(QtCore.QThread):
    updateEvent = QtCore.pyqtSignal(list, name="update")
    startEvent = QtCore.pyqtSignal()

    def __init__(
        self,
        discreteRadioBtn: QtWidgets.QRadioButton,
        intCpuRadioBtn: QtWidgets.QRadioButton,
    ):
        super().__init__()
        self.discreteRadioBtn = discreteRadioBtn
        self.intCpuRadioBtn = intCpuRadioBtn
        self.generate_files = None
        self.the_dir = None
        self.set_default_values()
        self.is_running = False

    def run(self) -> None:
        self.is_running = True
        self.startEvent.emit()
        if self.generate_files:
            if sys.platform == "win32":
                from scripts.get_windows_specs import generate_win_files

                generate_win_files()
            else:
                peracommon.generate_files(self.the_dir)
        # TODO: parse everything, remove '[]' from updateEvent

        self.updateEvent.emit([])
        self.set_default_values()

    def set_default_values(self):
        self.generate_files = False
        self.the_dir = "tmp"
        self.is_running = True


class Uploader(QtCore.QThread):
    successEvent = QtCore.pyqtSignal(str)
    failureEvent = QtCore.pyqtSignal(str, str)

    def __init__(
        self,
        data: list,
        tarallo_url: str,
        tarallo_token: str,
        bulk_identifier: str,
        overwrite: bool,
    ):
        super().__init__()
        self.data = data
        self.tarallo_url = tarallo_url
        self.tarallo_token = tarallo_token
        self.bulk_identifier = bulk_identifier
        self.overwrite = overwrite

    def run(self) -> None:
        try:
            tarallo = Tarallo.Tarallo(self.tarallo_url, self.tarallo_token)
            ver = tarallo.bulk_add(self.data, self.bulk_identifier, self.overwrite)
            if ver:
                # TODO: replace lollone with the actual code asd
                self.successEvent.emit(self.bulk_identifier)
            else:
                self.failureEvent.emit("cannot_upload", self.bulk_identifier)

        except NoInternetConnectionError:
            self.failureEvent.emit("cannot_reach", self.bulk_identifier)


def tarallo_success_dialog(url: str):
    dialog = QtWidgets.QMessageBox(
        QtWidgets.QMessageBox.Information,
        "Upload successful",
        "Upload successful! Now go to TARALLO and finish the job.",
    )
    std_width = (
        QtWidgets.QApplication.style()
        .standardIcon(QtWidgets.QStyle.SP_MessageBoxWarning)
        .availableSizes()[-1]
        .width()
    )
    dialog.setIconPixmap(
        QtGui.QPixmap("data/pear_emoji.png").scaledToWidth(
            std_width, QtCore.Qt.SmoothTransformation
        )
    )
    dialog.setStandardButtons(QtWidgets.QMessageBox.Ok)
    view_on_tarallo_button = dialog.addButton("View on TARALLO", dialog.ActionRole)
    dialog.exec_()
    if dialog.clickedButton() == view_on_tarallo_button:
        url = QtCore.QUrl(url)
        if not QtGui.QDesktopServices.openUrl(url):
            QtWidgets.QMessageBox.warning(
                dialog, "Cannot Open Url", f"Could not open url {url}"
            )
        return True
    return False


def main():
    # noinspection PyBroadException
    try:
        load_dotenv()
        tarallo_url = env["TARALLO_URL"]
        tarallo_token = env["TARALLO_TOKEN"]
        app = QtWidgets.QApplication(sys.argv)
        # This is EXTREMELY IMPORTANT, DON'T TACH [sic], DO NOT REMOVE IT EVER
        # noinspection PyUnusedLocal
        window = Ui(app, tarallo_url, tarallo_token)
        app.exec_()

    except KeyboardInterrupt:
        print("KeyboardInterrupt")

    except BaseException:
        print(traceback.print_exc(file=sys.stdout))


if __name__ == "__main__":
    main()
