#!/usr/bin/env python3
import json
import os
from pathlib import Path
import shutil
import sys
import time
import traceback
import urllib.parse
import urllib.request
from collections import defaultdict
from os import environ as env
from os.path import expanduser
from typing import Dict, List, Optional
from urllib.error import URLError

# noinspection PyUnresolvedReferences
import PyQt5.QtWidgets
from dotenv import load_dotenv
from PyQt5 import QtCore, QtGui, QtWidgets, uic
from PyQt5.QtCore import QAbstractTableModel
from pytarallo import Tarallo
from pytarallo.Errors import NoInternetConnectionError

import peracommon
import prettyprinter
from peracommon import env_to_bool
import signal

from loguru import logger
from crash_reporting import send_crash_notification

logdir_path = "logs"

VERSION = "1.0.0"

URL = {
    "website": "https://weeeopen.polito.it",
    "source_code": "https://github.com/WEEE-Open/peracotta",
}

PATH = {
    "UI": "assets/interface.ui",
    "TARALLOUPLOADDIALOG": "assets/uploadTaralloDialog.ui",
    "ERRORDIALOG": "assets/error.ui",
    "JSON": "copy_this_to_tarallo.json",
    "FEATURES": "features.json",
    "THEMES": "assets/themes/",
    "TMP_FILES": "tmp/",
    "ICON": "assets/ui/pear_emoji.png",
}

ICON = {
    "case": "assets/toolbox/case.png",
    "ram": "assets/toolbox/ram.png",
    "cpu": "assets/toolbox/cpu.png",
    "graphics-card": "assets/toolbox/gpu.png",
    "odd": "assets/toolbox/odd.png",
    "hdd": "assets/toolbox/hdd.png",
    "ssd": "assets/toolbox/ssd.png",
    "motherboard": "assets/toolbox/motherboard.png",
    "wifi-card": "assets/toolbox/wifi-card.png",
    "psu": "assets/toolbox/psu.png",
    "monitor": "assets/toolbox/monitor.png",
    "keyboard": "assets/toolbox/keyboard.png",
    "mouse": "assets/toolbox/mouse.png",
}

DEFAULT_PROGRESS_BAR_STYLE = (
    "QStatusBar::item {"
    "min-height: 12px;"
    "max-height: 12px;"
    "}"
    "QProgressBar {"
    "min-height: 14px;"
    "max-height: 14px;"
    "}"
    "QProgressBar::chunk {"
    "background-color: #00963A;"
    "width: 50px;"
    "}"
)


class Ui(QtWidgets.QMainWindow):
    def __init__(
        self,
        app: QtWidgets.QApplication,
        tarallo_url: str,
        tarallo_token: str,
    ) -> None:
        super(Ui, self).__init__()
        uic.loadUi(PATH["UI"], self)
        self.app = app
        self.uploader = None
        self.taralloDialog = None
        self.data = list(dict())
        self.tarallo_url = tarallo_url
        self.tarallo_token = tarallo_token
        self.useful_default_features = dict()
        self.encountered_types_count = defaultdict(lambda: 0)
        self.active_theme = str()

        self.setWindowIcon(QtGui.QIcon(PATH["ICON"]))

        # shortcuts
        self.refreshThemeShortcut = QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+R"), self)
        self.refreshThemeShortcut.activated.connect(self.refresh_theme)

        # Output toolbox
        self.outputScrollArea = self.findChild(QtWidgets.QScrollArea, "outputScrollArea")
        self.itemToolBox = None

        # App settings
        self.settings = QtCore.QSettings("WEEE Open", "PERACOTTA")

        # Gpu location layout
        self.gpuGroupBox = self.findChild(QtWidgets.QGroupBox, "gpuGroupBox")

        # Radio buttons
        self.discreteRadioBtn = self.findChild(QtWidgets.QRadioButton, "discreteRadioBtn")
        self.intCpuRadioBtn = self.findChild(QtWidgets.QRadioButton, "intCpuRadioBtn")
        self.intMoboRadioBtn = self.findChild(QtWidgets.QRadioButton, "intMoboRadioBtn")
        self.bothGpuRadioBtn = self.findChild(QtWidgets.QRadioButton, "bothGpuRadioBtn")

        # Selectors area
        self.selectorsWidget = self.findChild(QtWidgets.QWidget, "selectorsWidget")
        self.selectorsScrollArea = self.findChild(QtWidgets.QScrollArea, "selectorsScrollArea")

        self.addItemComboBox = self.findChild(QtWidgets.QComboBox, "addItemComboBox")
        self.addItemComboBox.addItem("Select Type --")
        self.addItemComboBox.currentTextChanged.connect(self.add_toolbox_item)
        self.addItemComboBox.wheelEvent = lambda stop_wheel_event: None

        # 'select/deselect all' buttons
        self.selectAllBtn = self.findChild(QtWidgets.QPushButton, "selectBtn")
        self.selectAllBtn.clicked.connect(self.select_all_checkboxes)
        self.deselectAllBtn = self.findChild(QtWidgets.QPushButton, "deselectBtn")
        self.deselectAllBtn.clicked.connect(self.deselect_all_checkboxes)

        # Owner line edit
        self.ownerLineEdit = self.findChild(QtWidgets.QLineEdit, "ownerLineEdit")

        # Generate data button
        self.generateBtn = self.findChild(QtWidgets.QPushButton, "generateBtn")
        self.generateBtn.clicked.connect(self.generate)

        # Reset selectors button
        self.resetBtn = self.findChild(QtWidgets.QPushButton, "resetBtn")
        self.resetBtn.clicked.connect(self.reset_setup_group)

        # Save JSON button
        self.saveJsonBtn = self.findChild(QtWidgets.QPushButton, "saveJsonBtn")
        self.saveJsonBtn.clicked.connect(self.save_json)

        # Upload to tarallo button
        self.uploadBtn = self.findChild(QtWidgets.QPushButton, "uploadBtn")
        self.uploadBtn.clicked.connect(self.tarallo_dialog)

        # File actions
        self.actionOpen = self.findChild(QtWidgets.QAction, "actionOpen")
        self.actionOpen.triggered.connect(self.open_json)
        self.actionOpenLastJson = self.findChild(QtWidgets.QAction, "actionOpenLastJson")
        self.actionOpenLastJson.triggered.connect(self.open_latest_json)
        self.actionOpenJson = self.findChild(QtWidgets.QAction, "actionOpenJson")
        self.actionOpenJson.triggered.connect(self.show_json)
        self.actionLoadRawFiles = self.findChild(QtWidgets.QAction, "actionLoadRawFiles")
        self.actionLoadRawFiles.triggered.connect(self._load_raw_files)
        self.actionExit = self.findChild(QtWidgets.QAction, "actionExit")
        self.actionExit.triggered.connect(self.close)

        # Options actions
        self.menuTheme = self.findChild(QtWidgets.QMenu, "menuTheme")
        action = list()
        action.append(self.menuTheme.addAction("Default"))
        action[-1].triggered.connect(lambda: self.set_theme("default"))
        for theme_file in os.listdir(PATH["THEMES"]):
            theme = theme_file.rstrip(".css")
            action.append(self.menuTheme.addAction(theme))
            action[-1].triggered.connect((lambda t: lambda: self.set_theme(t))(theme))

        # Help actions
        self.actionAboutUs = self.findChild(QtWidgets.QAction, "actionAboutUs")
        self.actionAboutUs.triggered.connect(self.open_website)
        self.actionSourceCode = self.findChild(QtWidgets.QAction, "actionSourceCode")
        self.actionSourceCode.triggered.connect(self.open_source_code)
        self.actionVersion = self.findChild(QtWidgets.QAction, "actionVersion")
        self.actionVersion.triggered.connect(self.show_version)

        # Status bar widgets
        self.progressBar = QtWidgets.QProgressBar()
        self.statusBar().addPermanentWidget(self.progressBar)
        self.progressBar.hide()
        # self.statusBar().setStyleSheet(DEFAULT_PROGRESS_BAR_STYLE)

        # Setup peracotta QThread
        self.perathread = PeracottaThread(self)
        self.perathread.updateEvent.connect(self.peracotta_results)
        self.perathread.startEvent.connect(self.show_busy_progress_bar)
        self.perathread.errorEvent.connect(self.peracotta_error)

        self.errorDialog = None

        self.show()
        self.setup()

    def setup(self):
        self.get_settings()
        self.set_theme(self.active_theme)
        self.download_features()

        # Set item types available in the add item combo box
        for type_key in self.useful_default_features["values"]["type"]:
            type_value = self.useful_default_features["values"]["type"][type_key]
            self.addItemComboBox.addItem(type_value)
            if type_key in ICON:
                icon = QtGui.QIcon(ICON[type_key])
                self.addItemComboBox.setItemIcon(self.addItemComboBox.count() - 1, icon)

        # Set up the item toolbox
        self.itemToolBox = ToolBoxWidget(self.data, self.useful_default_features, self.encountered_types_count)
        self.outputScrollArea.setWidget(self.itemToolBox)

        self.reset_toolbox()

        # Set the selectors widget
        layout = self.selectorsWidget.layout()
        niy = peracommon.ParserComponents.not_implemented_yet()
        for item in peracommon.ParserComponents:
            checkbox = QtWidgets.QCheckBox(item.value)
            if item in niy:
                checkbox.setEnabled(False)
            layout.addWidget(checkbox)
        self.reset_setup_group()

    def download_features(self):
        # self.useful_default_features must be set correctly, otherwise the GUI will fail to load
        try:
            tarallo_auto_download = env_to_bool(env.get("TARALLO_FEATURES_AUTO_DOWNLOAD", "1"))
            self.load_features_file(tarallo_auto_download)
        except Exception as e:
            title = "Cannot download features"
            message = f"Failed to download features from TARALLO: {str(e)}"
            if self.useful_default_features == {}:
                QtWidgets.QMessageBox.critical(
                    self,
                    title,
                    message + "\n\nPeracotta will now terminate.\nIf the problem persists, you can try peracruda instead.",
                )
                exit(1)
            else:
                QtWidgets.QMessageBox.warning(self, title, message)

    def get_settings(self):
        self.active_theme = self.settings.value("last_theme")
        if self.active_theme is None:
            self.active_theme = "default"

    @staticmethod
    def _backup_features_json() -> bool:
        here = os.path.dirname(os.path.realpath(__file__))
        try:
            shutil.copy2(
                os.path.join(here, "features.json"),
                os.path.join(here, "features.json.bak"),
            )
        except FileNotFoundError:
            return False
        return True

    @staticmethod
    def _restore_features_json() -> bool:
        here = os.path.dirname(os.path.realpath(__file__))
        try:
            shutil.move(
                os.path.join(here, "features.json.bak"),
                os.path.join(here, "features.json"),
            )
        except FileNotFoundError:
            return False
        return True

    def load_features_file(self, auto_update: bool):
        self.useful_default_features = {}
        has_file = False
        error = None

        try:
            mtime = os.path.getmtime(PATH["FEATURES"])
            has_file = True
        except FileNotFoundError:
            mtime = 0

        if auto_update and time.time() - mtime > 60 * 60 * 12:
            # TODO: etag/if-modified-since
            request = urllib.request.Request(url=f"{self.tarallo_url}/features.json")
            request.add_header("User-Agent", "peracotta")
            request.add_header("Accept", "application/json")
            self._backup_features_json()
            # noinspection PyBroadException
            try:
                with urllib.request.urlopen(request) as response:
                    with open("features.json", "wb") as out:
                        shutil.copyfileobj(response, out)
                        has_file = True
            except URLError as e:
                if hasattr(e, "reason"):
                    error = "Connection error: " + str(e.reason)
                elif hasattr(e, "code"):
                    error = "Server error: " + str(e.code)
            except BaseException as e:
                error = "Some error: " + str(e)

            if error:
                has_file = self._restore_features_json()

        if has_file:
            self._parse_features_file()

        if error:
            raise Exception(error)
        if not has_file and not auto_update:
            raise Exception("features.json file not present and automatic download is disabled")

    def _parse_features_file(self):
        with open(PATH["FEATURES"], "r") as file:
            default_feature_names = {}
            default_feature_types = {}
            default_feature_values = {}
            default_features = json.load(file)
            for group in default_features["features"]:
                for feature in default_features["features"][group]:
                    name = feature["name"]
                    default_feature_names[name] = feature["printableName"]
                    default_feature_types[name] = feature["type"]
                    if "values" in feature:
                        default_feature_values[name] = feature["values"]
            self.useful_default_features = {
                "names": default_feature_names,
                "types": default_feature_types,
                "values": default_feature_values,
            }

    # gui utilities

    def reset_toolbox(self):
        for idx in range(self.itemToolBox.count()):
            self.itemToolBox.removeItem(0)

    def open_url(self, url_type: str):
        url = QtCore.QUrl(url_type)
        if not QtGui.QDesktopServices.openUrl(url):
            QtWidgets.QMessageBox.warning(self, "Cannot Open Url", f"Could not open url {url_type}")

    def set_theme(self, theme: str):
        if theme == "default":
            self.app.setStyleSheet("")
            self.app.setStyleSheet("QWidget {" "font-size: 10pt;" "}")
            self.active_theme = "default"
        else:
            with open(f"{PATH['THEMES']}{theme}.css", "r") as file:
                self.app.setStyleSheet(file.read())
        self.settings.setValue("last_theme", theme)
        self.active_theme = theme

    def refresh_theme(self):
        if self.active_theme == "default":
            return
        with open(f"{PATH['THEMES']}{self.active_theme}.css", "r") as file:
            self.app.setStyleSheet(file.read())

    def show_busy_progress_bar(self):
        self.progressBar.setRange(0, 0)
        self.progressBar.show()

    def select_all_checkboxes(self):
        for checkbox in self.selectorsWidget.findChildren(QtWidgets.QCheckBox):
            if checkbox.isEnabled():
                checkbox.setChecked(True)

    def deselect_all_checkboxes(self):
        for checkbox in self.selectorsWidget.findChildren(QtWidgets.QCheckBox):
            checkbox.setChecked(False)

    def get_file_directory_dialog(self):
        the_dir = QtWidgets.QFileDialog.getOpenFileName(
            self,
            "Open JSON",
            f"{expanduser('~')}",
            f"JSON (*.json);;All Files (*)",
        )
        return the_dir[0]

    def get_directory_dialog(self):
        the_dir = QtWidgets.QFileDialog.getExistingDirectory(self, "Open JSON", f"{expanduser('~')}")
        return the_dir if the_dir != "" else None

    # tarallo utilities

    def upload_to_tarallo(self, checkbox: bool, bulk_id=None):
        if bulk_id == "":
            bulk_id = None
        self.uploader = Uploader(peracommon.make_tree(self.data), self.tarallo_url, self.tarallo_token, bulk_id, checkbox)
        self.uploader.successEvent.connect(self.tarallo_success)
        self.uploader.failureEvent.connect(self.tarallo_failure)
        self.uploader.start()

    def tarallo_success(self, code: str):
        self.uploader = None
        url = f"{self.tarallo_url}/bulk/import#{urllib.parse.quote(code)}"
        tarallo_success_dialog(url)

    def tarallo_failure(self, case: str, bulk_id: str):
        self.uploader = None
        if case == "cannot_upload":
            QtWidgets.QMessageBox.warning(
                self,
                "Cannot upload to T.A.R.A.L.L.O.",
                "Cannot upload, try to change the bulk identifier or check the overwrite checkbox.",
            )
            self.tarallo_dialog(bulk_id)
        elif case == "cannot_reach":
            QtWidgets.QMessageBox.warning(
                self,
                "Unable to reach the T.A.R.A.L.L.O.",
                "Please connect this PC to the Internet and try again.",
            )

    # buttons functions

    def reset_setup_group(self):
        # reset gpu location
        for radioBtn in self.gpuGroupBox.findChildren(QtWidgets.QRadioButton):
            radioBtn.setAutoExclusive(False)
            radioBtn.setChecked(False)
            radioBtn.setAutoExclusive(True)

        # reset checkboxes
        defaults = set(peracommon.ParserComponents.all_names()) - {
            peracommon.ParserComponents.MONITOR.value,
            peracommon.ParserComponents.INPUT.value,
        }

        for checkbox in self.selectorsWidget.findChildren(QtWidgets.QCheckBox):
            checkbox: QtWidgets.QCheckBox
            if checkbox.text() in defaults and checkbox.isEnabled():
                checkbox.setChecked(True)
            else:
                checkbox.setChecked(False)
                checkbox.setStyleSheet("text-decoration: line-through;")

        # reset owner
        self.ownerLineEdit.clear()

    def gpu_location_from_buttons(self):
        if self.discreteRadioBtn.isChecked():
            return peracommon.GpuLocation.DISCRETE
        if self.intCpuRadioBtn.isChecked():
            return peracommon.GpuLocation.CPU
        if self.intMoboRadioBtn.isChecked():
            return peracommon.GpuLocation.MOTHERBOARD
        if self.bothGpuRadioBtn.isChecked():
            QtWidgets.QMessageBox.information(
                self,
                "Warning",
                "The integrated GPU cannot be detected in this configuration: disconnect the dedicated one and re-run peracotta if you want to parse it, or edit manually.",
            )
            return peracommon.GpuLocation.DISCRETE
        else:
            QtWidgets.QMessageBox.warning(self, "Warning", "Please, select one of the GPU locations to proceed.")
            return None

    def get_selected_filters(self):
        filters = set()
        for checkbox in self.selectorsWidget.findChildren(QtWidgets.QCheckBox):
            checkbox: QtWidgets.QCheckBox
            if checkbox.isChecked():
                filters.add(peracommon.ParserComponents(checkbox.text()))
        return filters

    def generate(self):
        if self.perathread.isRunning():
            return

        if not self.set_thread_buttons_values():
            self.perathread.set_default_values()
            return

        if sys.platform != "win32":
            use_sudo = peracommon.env_to_bool(env.get("GENERATE_FILES_USE_SUDO", "1"))
            ask_sudo_pass = peracommon.env_to_bool(env.get("GENERATE_FILES_ASK_SUDO_PASSWORD", "1"))

            if use_sudo and "NOPASSWD: ALL" in os.popen("sudo -l").read():
                ask_sudo_pass = False

            self.perathread.use_sudo = use_sudo

            if use_sudo and ask_sudo_pass:
                got_it = self._ask_sudo_pass()
                if not got_it:
                    return
            else:
                self.perathread.sudo_passwd = None

        self.perathread.generate_files = True
        # TODO: shouldn't the next 2 lines be reversed?
        self.perathread.begin()
        self.reset_toolbox()

    def set_thread_buttons_values(self):
        gpu_location = self.gpu_location_from_buttons()
        if gpu_location is None:
            return False
        self.perathread.gpu_location = gpu_location
        self.perathread.owner = self.ownerLineEdit.text()
        self.perathread.filters = self.get_selected_filters()
        return True

    def _ask_sudo_pass(self):
        sudo_passwd, ok = QtWidgets.QInputDialog.getText(
            self,
            "Insert sudo password",
            "Insert sudo password:",
            QtWidgets.QLineEdit.Password,
        )
        if ok:
            self.perathread.sudo_passwd = sudo_passwd
            return True
        else:
            self.perathread.sudo_passwd = None
            return False

    def save_json(self):
        if self.data is None:
            QtWidgets.QMessageBox.warning(self, "Warning", "There is nothing to be saved")
            return
        the_dir = QtWidgets.QFileDialog.getSaveFileName(
            self,
            "Save Peracotta JSON",
            f"{expanduser('~')}",
            "JSON (*.json);;Text file (*.txt);;All Files (*)",
        )
        if the_dir[0] == "":
            return
        with open(the_dir[0], "w") as file:
            file.write(f"{json.dumps(peracommon.make_tree(self.data), indent=2)}")

    def tarallo_dialog(self, bulk_id=str()):
        if len(self.data) == 0:
            QtWidgets.QMessageBox.warning(self, "Warning", "There is nothing to be uploaded")
            return
        if not bulk_id:
            bulk_id = ""
        taralloDialog = TaralloUploadDialog(self, bulk_id)
        taralloDialog.signal.connect(self.upload_to_tarallo)

    def add_toolbox_item(self):
        if self.addItemComboBox.currentIndex() == 0:
            return
        else:
            item_type = self.addItemComboBox.currentText().lower()
            self.itemToolBox.add_item(item_type=item_type, single_item=True)
            if self.data is None:
                self.data = []
            self.data.append({})
            self.addItemComboBox.setCurrentIndex(0)

    # menu actions

    def open_json(self, path: str = ""):
        if not path:
            path = self.get_file_directory_dialog()
        if path == "":
            self.data = None
            return
        try:
            with open(path, "r") as file:
                self.data = json.load(file)
        except FileNotFoundError as exc:
            QtWidgets.QMessageBox.warning(self, "Error", f"File not found.\n{exc.args[1]}")

        self.data = peracommon.unmake_tree(self.data)
        self.settings.setValue("latest_json", path)
        self.itemToolBox.load_items(self.data)

    def open_latest_json(self):
        for key in self.settings.childKeys():
            if "latest_json" in key:
                self.open_json(self.settings.value("latest_json"))

    # the checked parameter exists for QAction::triggered
    # noinspection PyUnusedLocal

    def _load_raw_files(self, checked):
        self.load_raw_files()

    def load_raw_files(self, path: str = ""):
        if self.perathread.isRunning():
            return

        if not self.set_thread_buttons_values():
            self.perathread.set_default_values()
            return

        if path == "":
            path = self.get_directory_dialog()
        if path is None:
            self.perathread.set_default_values()
            return
        self.perathread.generate_files = False
        self.perathread.files_path = path

        # TODO: shouldn't the next 2 lines be reversed?
        self.perathread.begin()
        self.reset_toolbox()

    def show_json(self):
        if self.data is None:
            return
        JsonWidget(peracommon.make_tree(self.data), self.size())

    def open_website(self):
        self.open_url(URL["website"])

    def open_source_code(self):
        self.open_url(URL["source_code"])

    def show_version(self):
        QtWidgets.QMessageBox.about(self, "Version", f"Peracotta v{VERSION}")

    # multithread
    def peracotta_results(self, data: list):
        self.progressBar.setRange(0, 1)  # disable statusBar's progressBar
        self.progressBar.hide()
        if not data:
            return
        self.data = data
        self.itemToolBox.load_items(self.data)

    def peracotta_error(self, error_type: str, error: str):
        self.errorDialog = ErrorDialog(self, error_type, error)
        self.progressBar.setRange(0, 1)  # disable statusBar's progressBar
        self.progressBar.hide()

    # close event
    def closeEvent(self, a0: QtGui.QCloseEvent) -> None:
        if self.perathread.isRunning():
            self.perathread.terminate()


class PeracottaThread(QtCore.QThread):
    updateEvent = QtCore.pyqtSignal(list, name="update")
    errorEvent = QtCore.pyqtSignal(str, str, name="error")
    startEvent = QtCore.pyqtSignal()

    def __init__(self, main_window: QtWidgets.QMainWindow):
        super().__init__()
        self.main_window = main_window

        self.gpu_location = None
        self.owner = ""
        self.files_path = PATH["TMP_FILES"]
        self.raw_files_path = ""
        self.generate_files = False
        self.filters = set()
        self.use_sudo = False
        self.sudo_passwd = None
        # self.set_default_values()

    def begin(self, generate_files: bool = True, raw_files_path: str = ""):
        self.generate_files = generate_files
        self.raw_files_path = raw_files_path
        self.start()

    def run(self) -> None:
        self.startEvent.emit()
        result = []
        try:
            if sys.platform == "win32":
                from scripts.get_windows_specs import generate_win_files

                generate_win_files()
                result = self.process_win_files()
            else:
                if self.generate_files:
                    # message = peracommon.check_required_files(self.files_path, is_gui=True)
                    # if message != "":
                    #     QtWidgets.QMessageBox.critical(self.main_window, "Error", message)
                    try:
                        self.files_path = peracommon.generate_files(self.files_path, self.use_sudo, self.sudo_passwd)
                    except peracommon.SudoError as error:
                        self.errorEvent.emit("Sudo error", str(error))
                        return
                    except peracommon.GenerateFilesError as error:
                        self.errorEvent.emit("Generate files error", str(error))
                        return
                    if self.files_path is None:
                        QtWidgets.QMessageBox.warning(self.main_window, "Critical error", "Failed to generate files")
                        return
                result = peracommon.call_parsers(
                    self.files_path,
                    set(self.filters),
                    self.gpu_location,
                    False,
                )
            if self.owner != "":
                result = peracommon.add_owner(result, self.owner)
            result = peracommon.split_products(result)
        finally:
            self.set_default_values()
        self.updateEvent.emit(result)

    def set_default_values(self):
        self.gpu_location = None
        self.owner = ""
        self.files_path = PATH["TMP_FILES"]
        self.raw_files_path = ""
        self.generate_files = False
        self.filters = set()
        self.use_sudo = False
        self.sudo_passwd = None

    def process_win_files(self):
        import parsers.windows_parser as win

        result = win.parse_win_cpu_specs(self.files_path)
        result = result + win.parse_win_chassis_specs(self.files_path)
        result = result + win.parse_win_ram_specs(self.files_path)
        result = result + win.parse_win_motherboard_specs(self.files_path)
        return result


class ItemEnumDelegate(QtWidgets.QStyledItemDelegate):
    # class ItemEnumAlignDelegate(QtWidgets.QStyledItemDelegate):
    #     def initStyleOption(self, option, index):
    #         super().initStyleOption(option, index)
    #         option.displayAlignment = QtCore.Qt.AlignLeft

    def createEditor(self, parent, option, index):
        the_type = str(index.model().data(index, QtCore.Qt.UserRole))
        if the_type == "e":
            editor = QtWidgets.QComboBox(parent)
            editor.currentTextChanged.connect(self.handle_editor_change)
            editor.setEditable(True)
            return editor
        else:
            return super().createEditor(parent, option, index)

    def setEditorData(self, editor, index):
        model: CustomTableModel = index.model()
        if isinstance(editor, QtWidgets.QComboBox):
            values = model.row_all_enum_values_for_editor(index.row())
            current = model.row_current_enum_value_for_editor(index.row())
            if values and current:
                # editor.setItemDelegate(self.ItemEnumAlignDelegate(editor))
                for k, v in values.items():
                    editor.addItem(v, k)
                    i = editor.count() - 1
                    if current == k:
                        editor.setCurrentIndex(i)
        else:
            return super().setEditorData(editor, index)

    def setModelData(self, editor, model, index):
        if isinstance(editor, QtWidgets.QComboBox):
            model.setData(index, editor.currentData(), QtCore.Qt.EditRole)
        else:
            return super().setModelData(editor, model, index)

    def handle_editor_change(self):
        editor = self.sender()
        self.commitData.emit(editor)
        self.closeEditor.emit(editor)


class CustomTableView(QtWidgets.QTableView):
    def __init__(self):
        super().__init__()
        self.setItemDelegateForColumn(1, ItemEnumDelegate())

    def minimumSizeHint(self) -> QtCore.QSize:
        default_size = super().minimumSizeHint()

        frame = self.frameWidth() * 2

        header = self.verticalHeader().sizeHint().height()
        rows = self.verticalHeader().length()
        # rows = self.model().rowCount() * self.horizontalHeader().defaultSectionSize()
        h = header + rows + frame
        # print(f"{header} + {rows} + {frame} = {h} > {default_size.height()}")

        return QtCore.QSize(default_size.width(), h)

    def contextMenuEvent(self, event: QtGui.QContextMenuEvent) -> None:
        menu = QtWidgets.QMenu(self)
        remove_action = QtWidgets.QAction("Remove feature", self)
        remove_action.triggered.connect(self.remove_row)
        menu.addAction(remove_action)
        menu.popup(QtGui.QCursor.pos())

    def remove_row(self):
        self.model().removeRow(self.selectedIndexes()[1].row(), self.selectedIndexes()[1].parent())


class ToolBoxItem(QtWidgets.QWidget):
    def __init__(self, data: List[dict], features: dict, product: Optional[dict], default_features: dict):
        super().__init__()
        self.default_features = default_features

        self.main_layout = QtWidgets.QVBoxLayout()
        self.table = CustomTableView()
        self.features_combo_box = QtWidgets.QComboBox()
        self.feature_line_edit = QtWidgets.QLineEdit()
        self.feature_selector = QtWidgets.QComboBox()
        self.add_feature_button = QtWidgets.QPushButton("Add")
        self.add_feature_button.clicked.connect(self.add_feature)
        self.add_feature_button.setMinimumWidth(60)

        # setup
        self.table_setup(data, features, product, default_features)
        self.adder_layout = self._create_feature_adder()
        self.main_layout.addLayout(self.adder_layout)
        self.setLayout(self.main_layout)

    def external_size_hint_height(self):
        h1 = max(self.table.minimumSizeHint().height(), self.table.sizeHint().height())
        h2 = self.adder_layout.sizeHint().height()

        return h1 + h2

    def table_setup(self, data: List[dict], features: dict, product: Optional[dict], default_features: dict):
        ctm = CustomTableModel(data, features, product, default_features)
        ctm.emergency_resize.connect(self._do_the_emergency_resize)
        self.table.verticalHeader().hide()
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.setModel(ctm)
        self.table.setShowGrid(False)
        self.table.setAlternatingRowColors(True)
        self.table.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.table.verticalScrollBar().hide()
        self.table.verticalScrollBar().resize(0, 0)
        self.main_layout.addWidget(self.table)
        self.table.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.AdjustToContents)
        self.table.resizeColumnsToContents()
        self.table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)

        hh = PyQt5.QtWidgets.QHeaderView = self.table.horizontalHeader()
        hh.setSectionResizeMode(0, PyQt5.QtWidgets.QHeaderView.ResizeToContents)
        hh.setSectionResizeMode(1, PyQt5.QtWidgets.QHeaderView.Stretch)

    def _do_the_emergency_resize(self):
        self.parentWidget().parentWidget().updateGeometry()
        self.table.resizeColumnToContents(0)

    def _create_feature_adder(self):
        layout = QtWidgets.QHBoxLayout()
        layout.addWidget(self.features_combo_box)
        layout.addWidget(self.feature_line_edit)
        layout.addWidget(self.feature_selector)
        layout.addWidget(self.add_feature_button)
        for name in self.default_features["names"]:
            self.features_combo_box.addItem(self.default_features["names"][name])
        self.features_combo_box.currentTextChanged.connect(self.set_input_type)
        self.set_input_type()
        return layout

    def set_input_type(self):
        for the_type in self.default_features["types"]:
            if self.default_features["names"][the_type] == self.features_combo_box.currentText():
                # set input type
                if self.default_features["types"][the_type] == "e":
                    self.feature_line_edit.setHidden(True)
                    self.feature_selector.setHidden(False)
                    self.feature_selector.clear()
                    i = 0
                    for value in self.default_features["values"][the_type]:
                        self.feature_selector.addItem(self.default_features["values"][the_type][value])
                        self.feature_selector.setItemData(i, value)
                        i += 1
                else:
                    self.feature_line_edit.setHidden(False)
                    self.feature_selector.setHidden(True)
                # disable button if feature already in table
                if the_type in self.table.model().features_in_table():
                    self.set_add_control_enabled(False)
                else:
                    self.set_add_control_enabled(True)

    def add_feature(self):
        feature = list(self.default_features["types"])[self.features_combo_box.currentIndex()]
        if self.feature_line_edit.isVisible():
            value = self.feature_line_edit.text()
        elif self.feature_selector.isVisible():
            value = self.feature_selector.currentData()
        else:
            return
        model: CustomTableModel = self.table.model()
        ok = model.insert_row(feature, value)
        if ok:
            self.set_add_control_enabled(False)
        self.feature_line_edit.clear()

    def set_add_control_enabled(self, flag: bool):
        self.add_feature_button.setEnabled(flag)
        self.feature_line_edit.setEnabled(flag)
        self.feature_selector.setEnabled(flag)

    def minimumSizeHint(self) -> QtCore.QSize:
        return self.table.minimumSizeHint()


class ToolBoxWidget(QtWidgets.QToolBox):
    def __init__(self, data: List[dict], default_features: dict, encountered_types_count: dict):
        super().__init__()
        self.data = data
        self.default_features = default_features
        self.encountered_types_count = encountered_types_count
        self.menu = None

        # variables
        self.encountered_types_current_count = defaultdict(lambda: 0)

    def clear(self):
        for idx in range(self.count()):
            self.removeItem(0)
        self.encountered_types_count.clear()
        self.encountered_types_current_count.clear()

    def load_items(self, data: List[dict]):
        if data:
            self.clear()
            self.data = data
            self.types_count()

        # find brand, model and variant of all products in data
        products = {}
        for idx, entry in enumerate(self.data):
            if entry["type"] == "P":
                products[idx] = (entry["brand"], entry["model"], entry["variant"])

        for entry in self.data:
            self.add_item(entry)

        # remove scroll in toolbox's scrollAreas
        for scroll_area in self.findChildren(QtWidgets.QScrollArea):
            scroll_area.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
            scroll_area.verticalScrollBar().hide()
            scroll_area.verticalScrollBar().resize(0, 0)

    def add_item(self, item: Optional[dict] = None, item_type: Optional[str] = None, single_item: Optional[bool] = False):
        if single_item:
            self.data.append(
                {
                    "type": "I",
                    "features": {
                        "type": item_type,
                    },
                }
            )
            found_product = None
        else:
            found_product = self.find_matching_product(self.data, item.get("features", {}))

        if item and item["type"] != "I":
            return

        counter = ""

        if item_type is None and item:
            item_type = item["features"]["type"]
        if self.encountered_types_count[item_type] > 1:
            self.encountered_types_current_count[item_type] += 1
            counter = f" #{self.encountered_types_current_count[item_type]}"
        if single_item:
            features = self.data[-1]["features"]
        else:
            features = item["features"]

        self.addItem(
            ToolBoxItem(self.data, features, found_product, self.default_features),
            f"{self.print_type_cool(item_type)}{counter}",
        )
        if item_type in ICON:
            icon = QtGui.QIcon(ICON[item_type])
            self.setItemIcon(self.count() - 1, icon)

        self.set_context_menu()

    @staticmethod
    def find_matching_product(data: List[dict], features: dict):
        if "model" in features and "brand" in features and "variant" in features:
            for maybe in data:
                if maybe.get("type") == "P":
                    if ToolBoxWidget.bmv_match(features, maybe):
                        return maybe
        return None

    @staticmethod
    def bmv_match(dict1, dict2) -> bool:
        return dict1.get("brand") == dict2.get("brand") and dict1.get("model") == dict2.get("model") and dict1.get("variant") == dict2.get("variant")

    def set_context_menu(self):
        counter = 0
        for item in self.children():
            if type(item) == QtWidgets.QAbstractButton:
                item: QtWidgets.QAbstractButton
                item.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
                item.customContextMenuRequested.connect(self.show_menu)
                counter += 1

    def print_type_cool(self, the_type: str) -> str:
        if the_type in self.default_features["values"]["type"]:
            return self.default_features["values"]["type"][the_type]
        else:
            return the_type.title()

    def show_menu(self):
        button = self.sender()
        self.menu = QtWidgets.QMenu()
        remove_action = QtWidgets.QAction("Remove item", self)
        remove_action.triggered.connect(lambda: self.remove_item_from_toolbox(button))
        self.menu.addAction(remove_action)
        self.menu.popup(QtGui.QCursor.pos())

    def minimumSizeHint(self) -> QtCore.QSize:
        h = 0
        for child in self.children():
            if isinstance(child, QtWidgets.QScrollArea):
                if child.isHidden():
                    # print("Hidden!")
                    pass
                    # print(f"Hidden min {child.minimumSizeHint().height()}")
                    # print(f"Hidden {child.sizeHint().height()}")
                    # h += child.minimumSizeHint().height()
                else:
                    the_widget = child.widget()
                    if the_widget and isinstance(the_widget, ToolBoxItem):
                        hinted = the_widget.external_size_hint_height()
                        # print(f"Hinted: {hinted}")
                        h += hinted
                    else:
                        # h += max(child.sizeHint().height(), child.minimumSizeHint().height())
                        pass
            elif isinstance(child, QtWidgets.QAbstractButton):
                # print(f"{child}: {child.sizeHint().height()} {child.minimumSizeHint().height()}")
                # Why 1.5? Dunno, they're ~40 pixels and sizeHint is 25 (minimum 24).
                h += int(child.sizeHint().height() * 1.5)
        old = super().minimumSizeHint()
        if h > old.height():
            return QtCore.QSize(old.width(), h)
        return old

    def remove_item_from_toolbox(self, button):
        i = 0
        for item in self.children():
            if type(item) == QtWidgets.QAbstractButton:
                if item == button:
                    self.removeItem(i)
                    break
                else:
                    i += 1

    def removeItem(self, index: int) -> None:
        i = 0
        data_index = None
        for data_index, entry in enumerate(self.data):
            if entry["type"] != "I":
                continue
            if index == i:
                break
            i += 1

        item_to_remove = self.data[data_index]
        item_b = item_to_remove["features"].get("brand")
        item_m = item_to_remove["features"].get("model")
        item_v = item_to_remove["features"].get("variant")
        counter = 0
        product_index = None
        deleted = False
        if item_b and item_m and item_v:
            for idx, entry in enumerate(self.data):
                # count items with the same product
                if entry["type"] == "I" and idx != data_index:
                    test_b = entry["features"].get("brand")
                    test_m = entry["features"].get("model")
                    test_v = entry["features"].get("variant")
                    if item_b == test_b and item_m == test_m and item_v == test_v:
                        counter += 1
                # find the product itself
                elif entry["type"] == "P":
                    p_test_b = entry.get("brand")
                    p_test_m = entry.get("model")
                    p_test_v = entry.get("variant")
                    if item_b == p_test_b and item_m == p_test_m and item_v == p_test_v:
                        product_index = idx
            if counter <= 0 and product_index:
                # If both item and product have to be deleted, delete them
                # without f...messing up indexes
                if data_index >= product_index:
                    del self.data[data_index]
                    del self.data[product_index]
                else:
                    del self.data[product_index]
                    del self.data[data_index]
                deleted = True

        # All other cases (item with no product, product not found, other items linked to product):
        # just delete the product
        if not deleted:
            del self.data[data_index]

        widget_ref = self.widget(index)
        super().removeItem(index)
        widget_ref.deleteLater()

    def types_count(self, data: list = None):
        if data is not None:
            self.data = data
        for entry in self.data:
            if entry["type"] != "I":
                continue
            the_type = entry["features"]["type"]
            self.encountered_types_count[the_type] += 1


class CustomTableModel(QAbstractTableModel):
    emergency_resize = QtCore.pyqtSignal(name="emergency_resize")

    def __init__(self, data: List[dict], item_features: dict, product: Optional[dict], default_features: dict):
        super().__init__()

        self._data = data
        self.ref_features = item_features
        self.ref_product = product
        self.default_features = default_features

        self.features = {}
        self.feature_keys = []
        self._productize(item_features, product)

    def _productize(self, item_features: dict, product: Optional[dict]):
        if product:
            self.features = product["features"].copy()
        else:
            self.features = {}
        self.features.update(item_features)
        self.feature_keys = list(self.features)

    def rowCount(self, parent=QtCore.QModelIndex()):
        return len(self.feature_keys)

    def columnCount(self, parent=QtCore.QModelIndex()):
        return 2

    # noinspection PyMethodOverriding
    def headerData(self, section, orientation, role):
        if role == QtCore.Qt.DisplayRole and orientation == QtCore.Qt.Horizontal:
            if section == 0:
                return "Feature"
            else:
                return "Value"
        return None

    def flags(self, index):
        if index.column() == 1:
            return QtCore.Qt.ItemIsEditable | QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsSelectable
        else:
            return QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsSelectable

    def row_all_enum_values_for_editor(self, row: int) -> Optional[Dict[str, str]]:
        if row < 0 or row >= len(self.feature_keys):
            return None

        name = self.feature_keys[row]
        feature_type = self._get_feature_type(name)
        if feature_type == "e":
            return self.default_features["values"][name]
        return None

    def row_current_enum_value_for_editor(self, row: int):
        if row < 0 or row >= len(self.features):
            return None

        name = self.feature_keys[row]
        return self.features.get(name)

    # def _row_to_name(self, row) -> Optional[str]:
    #     for i, name in enumerate(self.combined):
    #         if i == row:
    #             return name
    #         else:
    #             return None

    def data(self, index, role=QtCore.Qt.DisplayRole):
        row = index.row()
        if row < 0 or row >= len(self.feature_keys):
            return None

        if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole or role == QtCore.Qt.UserRole:
            column = index.column()
            name = self.feature_keys[row]
            if column == 0:
                return self.default_features["names"].get(name, name)
            elif column == 1:
                feature_type = self._get_feature_type(name)
                if role == QtCore.Qt.UserRole:
                    return feature_type
                value = self.features[name]
                if feature_type == "e":
                    return self.default_features["values"][name].get(value, value)
                elif feature_type in ("d", "i"):
                    return prettyprinter.print_feature(name, value, feature_type)
                else:
                    return value
        elif role == QtCore.Qt.TextAlignmentRole:
            column = index.column()
            if column == 0:
                return QtCore.Qt.AlignLeft + QtCore.Qt.AlignVCenter
            elif column == 1:
                return QtCore.Qt.AlignLeft + QtCore.Qt.AlignVCenter

        return None

    # noinspection PyMethodOverriding
    def setData(self, index, value, role):
        if role == QtCore.Qt.EditRole:
            row = index.row()
            col = index.column()
            if col != 1:
                return False
            if row < 0 or row >= len(self.feature_keys):
                return False

            # Feature name
            name = self.feature_keys[row]
            # Normalize and validate, with EXTREME intensity
            ok, value = self.extreme_validation(name, value)
            if ok:
                # Add to features, this is a local copy of merged
                # item and product features
                self.features[name] = value
                product_to_add = None
                # Search if a product is there but not linked,
                # this is needed when a new item is added
                # since brand, model and variant are filled
                # one at a time
                if not self.ref_product:
                    product_to_add = ToolBoxWidget.find_matching_product(self._data, self.features)
                    if product_to_add:
                        self.beginResetModel()
                        self._productize(self.features, product_to_add)
                # If this feature exists in the product, add it there.
                # Otherwise, if the item has it, add it there.
                # Otherwise, find where it should be added.
                if self.ref_product and name in self.ref_product["features"]:
                    self.ref_product["features"][name] = value
                elif name in self.ref_features:
                    self.ref_features[name] = value
                    # If brand or model or variant was changed
                    # update product and related items, too
                    if self.ref_product and name in ("brand", "model", "variant"):
                        self._rename_product(self.ref_product, name, value)
                else:
                    self._add_to_ref(name, value)
                if product_to_add:
                    self.endResetModel()
                    self.emergency_resize.emit()
            return ok
        return False

    def extreme_validation(self, name: str, value: [str, int, float]) -> [bool, [str, int, float]]:
        feature_type = self._get_feature_type(name)
        if isinstance(value, str):
            value = value.strip()
        if feature_type == "e":
            value = str(value).lower()
            if value not in self.default_features["values"][name]:
                return False, None
        elif feature_type == "d":
            value = self._printable_to_value(name, value)
            value = float(value)
            if value <= 0:
                return False, None
        elif feature_type == "i":
            value = self._printable_to_value(name, value)
            value = int(round(value))
            if value <= 0:
                return False, None
        else:
            if len(value) <= 0:
                return False, None
        return True, value

    def _rename_product(self, product: dict, feature: str, value: str):
        if "brand" not in product or "model" not in product or "variant" not in product:
            # Sanity check, but should never happen
            return

        for maybe in self._data:
            if maybe.get("type") == "I":
                if ToolBoxWidget.bmv_match(product, maybe.get("features", {})):
                    maybe["features"][feature] = value

        # Finally, update product itself
        self.product[feature] = value

    def removeRow(self, row: int, parent: QtCore.QModelIndex() = ...) -> bool:
        # TODO: remove this limitation asd
        if not self._pre_delete_check(row):
            return False

        self.beginRemoveRows(parent, row, row)
        try:
            removed = self.feature_keys.pop(row)
            try:
                del self.features[removed]
                # TODO: remove from features but show product one if it exists
                if removed in self.ref_features:
                    del self.ref_features[removed]
                if self.ref_product and removed in self.ref_product["features"]:
                    del self.ref_product["features"][removed]
            except IndexError:
                pass
        except IndexError:
            self.endRemoveRows()
            return False
        self.endRemoveRows()
        return True

    def _pre_delete_check(self, row) -> bool:
        feature_name = self.feature_keys[row]
        if self.features.get(feature_name) in ("brand", "model", "variant"):
            if self.ref_product:
                return False
        return True

    @staticmethod
    def _printable_to_value(name, value):
        # noinspection PyBroadException
        try:
            value = prettyprinter.printable_to_value(prettyprinter.name_to_unit(name), value)
        except BaseException:
            value = 0
        return value

    def _get_feature_type(self, name):
        feature_type = self.default_features["types"].get(name, "s")
        return feature_type

    def insert_row(self, feature: str, value: str) -> bool:
        if feature in self.feature_keys:
            return False

        row_index = self.rowCount()

        ok, value = self.extreme_validation(feature, value)
        product_to_add = None
        if ok:
            self.beginInsertRows(QtCore.QModelIndex(), row_index, row_index)
            self.feature_keys.append(feature)
            self.features[feature] = value
            if not self.ref_product:
                product_to_add = ToolBoxWidget.find_matching_product(self._data, self.features)
            self._add_to_ref(feature, value)
            self.endInsertRows()

        if product_to_add:
            self.beginResetModel()
            self._productize(self.features, product_to_add)
            self.endResetModel()

        self.emergency_resize.emit()

        return ok

    def features_in_table(self):
        return self.feature_keys

    def _add_to_ref(self, name: str, value):
        if name in peracommon.item_only_features():
            target = self.ref_features
        elif self.ref_product:
            target = self.ref_product["features"]
        else:
            target = self.ref_features
        target[name] = value


class JsonWidget(QtWidgets.QDialog):
    def __init__(self, data: List[dict], window_size: QtCore.QSize):
        super().__init__()
        layout = QtWidgets.QVBoxLayout()
        text_edit = QtWidgets.QPlainTextEdit()
        text_edit.setWordWrapMode(QtGui.QTextOption.NoWrap)
        text_edit.setPlainText(f"{json.dumps(data, indent=2)}")
        text_edit.setReadOnly(True)
        layout.addWidget(text_edit)
        self.setLayout(layout)
        new_size = QtCore.QSize(int(window_size.width() * 0.8), int(window_size.height() * 0.8))
        self.resize(new_size)
        self.exec_()


class TaralloUploadDialog(QtWidgets.QDialog):
    signal = QtCore.pyqtSignal(bool, str, name="event")

    def __init__(self, parent: QtWidgets.QMainWindow, bulk_id: str = ""):
        super().__init__(parent)
        uic.loadUi(PATH["TARALLOUPLOADDIALOG"], self)

        self.setWindowTitle("Set bulk identifier")
        self.bulkLineEdit = self.findChild(QtWidgets.QLineEdit, "bulkLineEdit")
        self.bulkLineEdit.setText(bulk_id)
        self.okButton = self.findChild(QtWidgets.QPushButton, "okButton")
        self.okButton.clicked.connect(self.ok_signal)
        self.cancelButton = self.findChild(QtWidgets.QPushButton, "cancelButton")
        self.cancelButton.clicked.connect(self.cancel_signal)
        self.overwriteCheckBox = self.findChild(QtWidgets.QCheckBox, "overwriteCheckBox")
        self.show()

    def ok_signal(self):
        self.signal.emit(self.overwriteCheckBox.isChecked(), self.bulkLineEdit.text())
        self.close()

    def cancel_signal(self):
        self.close()


class ErrorDialog(QtWidgets.QDialog):
    def __init__(self, parent: QtWidgets.QMainWindow, title: str, detailed_error: str):
        super().__init__(parent)
        uic.loadUi(PATH["ERRORDIALOG"], self)
        self.setWindowTitle("Error")
        self.iconLabel = self.findChild(QtWidgets.QLabel, "iconLabel")
        self.textLabel = self.findChild(QtWidgets.QLabel, "textLabel")
        self.textLabel.setText(title)
        self.errorTextEdit = self.findChild(QtWidgets.QPlainTextEdit, "errorTextEdit")
        self.errorTextEdit.setPlainText(detailed_error)
        self.show()


class Uploader(QtCore.QThread):
    successEvent = QtCore.pyqtSignal(str)
    failureEvent = QtCore.pyqtSignal(str, str)

    def __init__(
        self,
        data: List[dict],
        tarallo_url: str,
        tarallo_token: str,
        bulk_identifier: str,
        overwrite: bool,
    ):
        super().__init__()
        self.data = data
        self.tarallo_url = tarallo_url
        self.tarallo_token = tarallo_token
        self.bulk_identifier = bulk_identifier
        self.overwrite = overwrite

    def run(self) -> None:
        try:
            tarallo = Tarallo.Tarallo(self.tarallo_url, self.tarallo_token)
            ver = tarallo.bulk_add(self.data, self.bulk_identifier, self.overwrite)
            if ver:
                # TODO: use generated identifier if none was provided
                self.successEvent.emit(self.bulk_identifier)
            else:
                self.failureEvent.emit("cannot_upload", self.bulk_identifier)

        except NoInternetConnectionError:
            self.failureEvent.emit("cannot_reach", self.bulk_identifier)


def tarallo_success_dialog(url: str):
    dialog = QtWidgets.QMessageBox(
        QtWidgets.QMessageBox.Information,
        "Upload successful",
        "Upload successful! Now go to TARALLO and finish the job.",
    )
    std_width = QtWidgets.QApplication.style().standardIcon(QtWidgets.QStyle.SP_MessageBoxWarning).availableSizes()[-1].width()
    dialog.setIconPixmap(QtGui.QPixmap(PATH["ICON"]).scaledToWidth(std_width, QtCore.Qt.SmoothTransformation))
    dialog.setStandardButtons(QtWidgets.QMessageBox.Ok)
    view_on_tarallo_button = dialog.addButton("View on TARALLO", dialog.ActionRole)
    dialog.exec_()
    if dialog.clickedButton() == view_on_tarallo_button:
        url = QtCore.QUrl(url)
        if not QtGui.QDesktopServices.openUrl(url):
            QtWidgets.QMessageBox.warning(dialog, "Cannot Open Url", f"Could not open url {url}")
        return True
    return False


@logger.catch()
def excepthook(exc_type, exc_value, exc_tb):
    critical_errors = []  # error classes that should crash the program

    QtWidgets.QMessageBox.warning(None, "Error", f"Peracotta encountered an exception ({exc_type.__name__}).\nSee the logs for the traceback.")

    if any([exc_type is exc_t for exc_t in critical_errors]):
        QtWidgets.QApplication.quit()

    raise exc_type(exc_value)  # doesn't close the program, but exits the function and shows up on the logs


def main():
    sys.excepthook = excepthook
    signal.signal(signal.SIGINT, signal.SIG_DFL)  # makes CTRL+C work

    logdir = Path(logdir_path)
    if not logdir.exists():
        os.mkdir(logdir)

    stdout_level = "DEBUG" if peracommon.env_to_bool(os.getenv("DEBUG")) else "WARNING"
    file_level = "DEBUG" if peracommon.env_to_bool(os.getenv("DEBUG")) else "INFO"

    log_format = "{time}\t{message}"
    logger.remove()
    logger.add(sys.stdout, format=log_format, level=stdout_level, colorize=True, backtrace=True, diagnose=True)
    logger.add(logdir.joinpath("peracotta.log"), format=log_format, level=file_level)

    # noinspection PyBroadException
    load_dotenv()
    tarallo_url = env["TARALLO_URL"]
    tarallo_token = env["TARALLO_TOKEN"]
    app = QtWidgets.QApplication(sys.argv)
    # This is EXTREMELY IMPORTANT, DON'T TACH [sic], DO NOT REMOVE IT EVER
    # noinspection PyUnusedLocal
    window = Ui(app, tarallo_url, tarallo_token)
    app.exec_()


if __name__ == "__main__":
    main()
