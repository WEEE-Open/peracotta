#!/usr/bin/env python3
from typing import Optional, List
from urllib.error import URLError

# noinspection PyUnresolvedReferences
from PyQt5 import uic, QtWidgets, QtCore, QtGui
from PyQt5.QtCore import QAbstractTableModel
from collections import defaultdict
from os.path import expanduser
from pytarallo import Tarallo
from pytarallo.Errors import NoInternetConnectionError
from dotenv import load_dotenv
from os import environ as env
import shutil
import time
import os
import urllib.parse
import urllib.request
import sys
import traceback
import json
import prettyprinter
import peracommon
from peracommon import env_to_bool


VERSION = "1.0.0"

URL = {
    "website": "https://weeeopen.polito.it",
    "source_code": "https://github.com/WEEE-Open/peracotta",
}

PATH = {
    "UI": "assets/interface.ui",
    "TARALLOUPLOADDIALOG": "assets/uploadTaralloDialog.ui",
    "JSON": "copy_this_to_tarallo.json",
    "FEATURES": "features.json",
    "THEMES": "assets/themes/",
    "TMP_FILES": "tmp/",
    "ICON": "assets/ui/pear_emoji.png",
}

ICON = {
    "case": "assets/toolbox/case.png",
    "ram": "assets/toolbox/ram.png",
    "cpu": "assets/toolbox/cpu.png",
    "graphics-card": "assets/toolbox/gpu.png",
    "odd": "assets/toolbox/odd.png",
    "hard disk": "assets/toolbox/hard disk.png",
    "motherboard": "assets/toolbox/motherboard.png",
    "wifi-card": "assets/toolbox/wifi-card.png",
    "psu": "assets/toolbox/psu.png",
    "monitor": "assets/toolbox/monitor.png",
    "keyboard": "assets/toolbox/keyboard.png",
    "mouse": "assets/toolbox/mouse.png",
}

DEFAULT_PROGRESS_BAR_STYLE = (
    "QStatusBar::item {"
    "min-height: 12px;"
    "max-height: 12px;"
    "}"
    "QProgressBar {"
    "min-height: 14px;"
    "max-height: 14px;"
    "}"
    "QProgressBar::chunk {"
    "background-color: #00963A;"
    "width: 50px;"
    "}"
)


class Ui(QtWidgets.QMainWindow):
    def __init__(
        self,
        app: QtWidgets.QApplication,
        tarallo_url: str,
        tarallo_token: str,
        tarallo_auto_download: bool,
    ) -> None:
        super(Ui, self).__init__()
        uic.loadUi(PATH["UI"], self)
        self.app = app
        self.taralloDialog = None
        self.data = list(dict())
        self.tarallo_url = tarallo_url
        self.tarallo_token = tarallo_token
        self.useful_default_features = dict()
        self.encountered_types_count = defaultdict(lambda: 0)
        self.active_theme = str()

        self.setWindowIcon(QtGui.QIcon(PATH["ICON"]))
        # self.useful_default_features must be set correctly, otherwise the GUI will fail to load
        try:
            self.load_features_file(tarallo_auto_download)
        except Exception as e:
            title = "Cannot download features"
            message = f"Failed to download features from TARALLO: {str(e)}"
            if self.useful_default_features == {}:
                QtWidgets.QMessageBox.critical(
                    self,
                    title,
                    message + "\n\nPeracotta will now terminate.\nIf the problem persists, you can try peracruda instead.",
                )
                exit(1)
            else:
                QtWidgets.QMessageBox.warning(self, title, message)

        # shortcuts
        self.refreshThemeShortcut = QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+R"), self)
        self.refreshThemeShortcut.activated.connect(self.refresh_theme)

        # Output toolbox
        self.outputScrollArea = self.findChild(QtWidgets.QScrollArea, "outputScrollArea")
        self.itemToolBox = ToolBoxWidget(self.data, self.useful_default_features, self.encountered_types_count)
        self.outputScrollArea.setWidget(self.itemToolBox)

        # App settings
        self.settings = QtCore.QSettings("WEEE Open", "PERACOTTA")

        # Gpu location layout
        self.gpuGroupBox = self.findChild(QtWidgets.QGroupBox, "gpuGroupBox")

        # Radio buttons
        self.discreteRadioBtn = self.findChild(QtWidgets.QRadioButton, "discreteRadioBtn")
        self.intCpuRadioBtn = self.findChild(QtWidgets.QRadioButton, "intCpuRadioBtn")
        self.intMoboRadioBtn = self.findChild(QtWidgets.QRadioButton, "intMoboRadioBtn")

        # Selectors area
        self.selectorsWidget = self.findChild(QtWidgets.QWidget, "selectorsWidget")
        self.selectorsScrollArea = self.findChild(QtWidgets.QScrollArea, "selectorsScrollArea")

        self.addItemComboBox = self.findChild(QtWidgets.QComboBox, "addItemComboBox")
        self.addItemComboBox.addItem("Select Type --")
        for the_type in self.useful_default_features["values"]["type"]:
            tye_type_fancy = self.useful_default_features["values"]["type"][the_type]
            self.addItemComboBox.addItem(tye_type_fancy)
            if the_type in ICON:
                icon = QtGui.QIcon(ICON[the_type])
                self.addItemComboBox.setItemIcon(self.addItemComboBox.count() - 1, icon)
        self.addItemComboBox.currentTextChanged.connect(self.add_toolbox_item)
        self.addItemComboBox.wheelEvent = lambda stop_wheel_event: None

        # select/deselect all buttons
        self.selectAllBtn = self.findChild(QtWidgets.QPushButton, "selectBtn")
        self.selectAllBtn.clicked.connect(self.select_all_checkboxes)
        self.deselectAllBtn = self.findChild(QtWidgets.QPushButton, "deselectBtn")
        self.deselectAllBtn.clicked.connect(self.deselect_all_checkboxes)

        # Owner line edit
        self.ownerLineEdit = self.findChild(QtWidgets.QLineEdit, "ownerLineEdit")

        # Generate data button
        self.generateBtn = self.findChild(QtWidgets.QPushButton, "generateBtn")
        self.generateBtn.clicked.connect(self.generate)

        # Reset selectors button
        self.resetBtn = self.findChild(QtWidgets.QPushButton, "resetBtn")
        self.resetBtn.clicked.connect(self.reset_setup_group)

        # Save JSON button
        self.saveJsonBtn = self.findChild(QtWidgets.QPushButton, "saveJsonBtn")
        self.saveJsonBtn.clicked.connect(self.save_json)

        # Upload to tarallo button
        self.uploadBtn = self.findChild(QtWidgets.QPushButton, "uploadBtn")
        self.uploadBtn.clicked.connect(self.tarallo_dialog)

        # File actions
        self.actionOpen = self.findChild(QtWidgets.QAction, "actionOpen")
        self.actionOpen.triggered.connect(self.open_json)
        self.actionOpenLastJson = self.findChild(QtWidgets.QAction, "actionOpenLastJson")
        self.actionOpenLastJson.triggered.connect(self.open_latest_json)
        self.actionOpenJson = self.findChild(QtWidgets.QAction, "actionOpenJson")
        self.actionOpenJson.triggered.connect(self.show_json)
        self.actionLoadRawFiles = self.findChild(QtWidgets.QAction, "actionLoadRawFiles")
        self.actionLoadRawFiles.triggered.connect(self.load_raw_files)
        self.actionExit = self.findChild(QtWidgets.QAction, "actionExit")
        self.actionExit.triggered.connect(self.close)

        # Options actions
        self.menuTheme = self.findChild(QtWidgets.QMenu, "menuTheme")
        action = list()
        action.append(self.menuTheme.addAction("Default"))
        action[-1].triggered.connect(lambda: self.set_theme("default"))
        for theme_file in os.listdir(PATH["THEMES"]):
            theme = theme_file.rstrip(".css")
            action.append(self.menuTheme.addAction(theme.title()))
            action[-1].triggered.connect((lambda t: lambda: self.set_theme(t))(theme))

        # Help actions
        self.actionAboutUs = self.findChild(QtWidgets.QAction, "actionAboutUs")
        self.actionAboutUs.triggered.connect(self.open_website)
        self.actionSourceCode = self.findChild(QtWidgets.QAction, "actionSourceCode")
        self.actionSourceCode.triggered.connect(self.open_source_code)
        self.actionVersion = self.findChild(QtWidgets.QAction, "actionVersion")
        self.actionVersion.triggered.connect(self.show_version)

        # Status bar widgets
        self.progressBar = QtWidgets.QProgressBar()
        self.statusBar().addPermanentWidget(self.progressBar)
        self.progressBar.hide()
        # self.statusBar().setStyleSheet(DEFAULT_PROGRESS_BAR_STYLE)

        # Setup peracotta QThread
        self.peracotta = Peracotta(
            self,
            self.discreteRadioBtn,
            self.intCpuRadioBtn,
            self.ownerLineEdit,
            PATH["TMP_FILES"],
        )
        self.peracotta.updateEvent.connect(self.peracotta_results)
        self.peracotta.startEvent.connect(self.show_busy_progress_bar)

        self.show()
        self.setup()

    def setup(self):
        self.get_settings()
        self.set_theme(self.active_theme)
        self.reset_toolbox()

        layout = self.selectorsWidget.layout()
        niy = peracommon.ParserComponents.not_implemented_yet()
        for item in peracommon.ParserComponents:
            checkbox = QtWidgets.QCheckBox(item.value)
            if item in niy:
                checkbox.setEnabled(False)
            layout.addWidget(checkbox)
        self.reset_setup_group()

    def get_settings(self):
        self.active_theme = self.settings.value("last_theme")
        if self.active_theme is None:
            self.active_theme = "default"

    @staticmethod
    def _backup_features_json() -> bool:
        here = os.path.dirname(os.path.realpath(__file__))
        try:
            shutil.copy2(
                os.path.join(here, "features.json"),
                os.path.join(here, "features.json.bak"),
            )
        except FileNotFoundError:
            return False
        return True

    @staticmethod
    def _restore_features_json() -> bool:
        here = os.path.dirname(os.path.realpath(__file__))
        try:
            shutil.move(
                os.path.join(here, "features.json.bak"),
                os.path.join(here, "features.json"),
            )
        except FileNotFoundError:
            return False
        return True

    def load_features_file(self, auto_update: bool):
        self.useful_default_features = {}
        has_file = False
        error = None

        try:
            mtime = os.path.getmtime(PATH["FEATURES"])
            has_file = True
        except FileNotFoundError:
            mtime = 0

        if auto_update and time.time() - mtime > 60 * 60 * 12:
            # TODO: etag/if-modified-since
            request = urllib.request.Request(url=f"{self.tarallo_url}/features.json")
            request.add_header("User-Agent", "peracotta")
            request.add_header("Accept", "application/json")
            self._backup_features_json()
            # noinspection PyBroadException
            try:
                with urllib.request.urlopen(request) as response:
                    with open("features.json", "w") as out:
                        shutil.copyfileobj(response, out)
                        has_file = True
            except URLError as e:
                if hasattr(e, "reason"):
                    error = "Connection error: " + str(e.reason)
                elif hasattr(e, "code"):
                    error = "Server error: " + str(e.code)
            except BaseException as e:
                error = "Some error: " + str(e)

            if error:
                has_file = self._restore_features_json()

        if has_file:
            self._parse_features_file()

        if error:
            raise Exception(error)
        if not has_file and not auto_update:
            raise Exception("features.json file not present and automatic download is disabled")

    def _parse_features_file(self):
        with open(PATH["FEATURES"], "r") as file:
            default_feature_names = {}
            default_feature_types = {}
            default_feature_values = {}
            default_features = json.load(file)
            for group in default_features["features"]:
                for feature in default_features["features"][group]:
                    name = feature["name"]
                    default_feature_names[name] = feature["printableName"]
                    default_feature_types[name] = feature["type"]
                    if "values" in feature:
                        default_feature_values[name] = feature["values"]
            self.useful_default_features = {
                "names": default_feature_names,
                "types": default_feature_types,
                "values": default_feature_values,
            }

    # gui utilities

    def reset_toolbox(self):
        for idx in range(self.itemToolBox.count()):
            self.itemToolBox.removeItem(0)

    def open_url(self, url_type: str):
        url = QtCore.QUrl(url_type)
        if not QtGui.QDesktopServices.openUrl(url):
            QtWidgets.QMessageBox.warning(self, "Cannot Open Url", f"Could not open url {url_type}")

    def set_theme(self, theme: str):
        if theme == "default":
            self.app.setStyleSheet("")
            self.active_theme = "default"
        else:
            with open(f"{PATH['THEMES']}{theme}.css", "r") as file:
                self.app.setStyleSheet(file.read())
        self.settings.setValue("last_theme", theme)
        self.active_theme = theme

    def refresh_theme(self):
        if self.active_theme == "default":
            return
        with open(f"{PATH['THEMES']}{self.active_theme}.css", "r") as file:
            self.app.setStyleSheet(file.read())

    def show_busy_progress_bar(self):
        self.progressBar.setRange(0, 0)
        self.progressBar.show()

    def select_all_checkboxes(self):
        for checkbox in self.selectorsWidget.findChildren(QtWidgets.QCheckBox):
            checkbox.setChecked(True)

    def deselect_all_checkboxes(self):
        for checkbox in self.selectorsWidget.findChildren(QtWidgets.QCheckBox):
            checkbox.setChecked(False)

    # tarallo utilities
    def upload_to_tarallo(self, checkbox: bool, bulk_id=None):
        if bulk_id == "":
            bulk_id = None
        uploader = Uploader(peracommon.make_tree(self.data), self.tarallo_url, self.tarallo_token, bulk_id, checkbox)
        uploader.successEvent.connect(self.tarallo_success)
        uploader.failureEvent.connect(self.tarallo_failure)

    def tarallo_success(self, code: str):
        url = f"{self.tarallo_url}/bulk/import#{urllib.parse.quote(code)}"
        tarallo_success_dialog(url)

    def tarallo_failure(self, case: str, bulk_id: str):
        if case == "cannot_upload":
            QtWidgets.QMessageBox.warning(
                self,
                "Cannot upload to T.A.R.A.L.L.O.",
                "Cannot upload, try to change the bulk identifier or check the overwrite checkbox.",
            )
            self.tarallo_dialog(bulk_id)
        elif case == "cannot_reach":
            QtWidgets.QMessageBox.warning(
                self,
                "Unable to reach the T.A.R.A.L.L.O.",
                "Please connect this PC to the Internet and try again.",
            )

    # buttons functions
    def reset_setup_group(self):
        # reset gpu location
        for radioBtn in self.gpuGroupBox.findChildren(QtWidgets.QRadioButton):
            radioBtn.setAutoExclusive(False)
            radioBtn.setChecked(False)
            radioBtn.setAutoExclusive(True)

        # reset checkboxes
        defaults = set(peracommon.ParserComponents.all_names()) - {
            peracommon.ParserComponents.MONITOR.value,
            peracommon.ParserComponents.INPUT.value,
        }

        for checkbox in self.selectorsWidget.findChildren(QtWidgets.QCheckBox):
            if checkbox.text() in defaults and checkbox.isEnabled():
                checkbox.setChecked(True)
            else:
                checkbox.setChecked(False)

        # reset owner
        self.ownerLineEdit.clear()

    def generate(self):
        if not (self.discreteRadioBtn.isChecked() or self.intCpuRadioBtn.isChecked() or self.intMoboRadioBtn.isChecked()):
            QtWidgets.QMessageBox.warning(self, "Warning", "Please, select one of the GPU locations to proceed.")
            return

        use_sudo = peracommon.env_to_bool(env.get("GENERATE_FILES_USE_SUDO", "1"))
        ask_sudo_pass = peracommon.env_to_bool(env.get("GENERATE_FILES_ASK_SUDO_PASSWORD", "1"))

        self.peracotta.use_sudo = use_sudo
        self.peracotta.sudo_passwd = None

        if use_sudo and ask_sudo_pass:
            got_it = self._ask_sudo_pass()
            if not got_it:
                return

        self.peracotta.generate_files = True
        self.peracotta.set_filters(self.selectorsWidget)
        # TODO: shouldn't the next 2 lines be reversed?
        self.peracotta.start()
        self.reset_toolbox()

    def _ask_sudo_pass(self):
        sudo_passwd, ok = QtWidgets.QInputDialog.getText(
            self,
            "Insert sudo password",
            "Insert sudo password:",
            QtWidgets.QLineEdit.Password,
        )
        if ok:
            self.peracotta.sudo_passwd = sudo_passwd
            return True
        else:
            self.peracotta.sudo_passwd = None
            return False

    def save_json(self):
        if self.data is None:
            QtWidgets.QMessageBox.warning(self, "Warning", "There is nothing to be saved")
            return
        the_dir = QtWidgets.QFileDialog.getSaveFileName(
            self,
            "Save Peracotta JSON",
            f"{expanduser('~')}",
            "JSON (*.json);;Text file (*.txt);;All Files (*)",
        )
        if the_dir[0] == "":
            return
        with open(the_dir[0], "w") as file:
            file.write(f"{json.dumps(peracommon.make_tree(self.data))}")

    def tarallo_dialog(self, bulk_id=str()):
        if self.data is None:
            QtWidgets.QMessageBox.warning(self, "Warning", "There is nothing to be uploaded")
            return
        if not bulk_id:
            bulk_id = ""
        self.taralloDialog = TaralloUploadDialog(bulk_id)
        self.taralloDialog.signal.connect(self.upload_to_tarallo)

    def add_toolbox_item(self):
        if self.addItemComboBox.currentIndex() == 0:
            return
        else:
            item_type = self.addItemComboBox.currentText().lower()
            self.itemToolBox.add_item(item_type=item_type, single_item=True)
            if self.data is None:
                self.data = []
            self.data.append({})
            self.addItemComboBox.setCurrentIndex(0)

    # menu actions
    def open_json(self, path: str = ""):
        self.itemToolBox.clear()

        if not path:
            the_dir = QtWidgets.QFileDialog.getOpenFileName(
                self,
                "Open JSON",
                f"{expanduser('~')}",
                f"JSON (*.json);;All Files (*)",
            )
            path = the_dir[0]
        if path == "":
            self.data = None
            return
        with open(path, "r") as file:
            self.data = json.load(file)

        self.data = peracommon.unmake_tree(self.data)
        self.settings.setValue("latest_json", path)
        self.itemToolBox.load_items(self.data)

    def open_latest_json(self):
        for key in self.settings.childKeys():
            if "latest_json" in key:
                self.open_json(self.settings.value("latest_json"))

    def load_raw_files(self):
        QtWidgets.QMessageBox.warning(self, "Oh no", "Not implemented yet!")

    def show_json(self):
        if self.data is None:
            return
        JsonWidget(peracommon.make_tree(self.data), self.size())

    def open_website(self):
        self.open_url(URL["website"])

    def open_source_code(self):
        self.open_url(URL["source_code"])

    def show_version(self):
        QtWidgets.QMessageBox.about(self, "Version", f"Peracotta v{VERSION}")

    # multithread
    def peracotta_results(self, data: list):
        self.progressBar.setRange(0, 1)  # disable statusBar's progressBar
        self.progressBar.hide()
        self.data = data
        self.itemToolBox.load_items(self.data)

    # close event
    def closeEvent(self, a0: QtGui.QCloseEvent) -> None:
        if self.peracotta.isRunning():
            self.peracotta.terminate()


class Peracotta(QtCore.QThread):
    updateEvent = QtCore.pyqtSignal(list, name="update")
    startEvent = QtCore.pyqtSignal()

    def __init__(
        self,
        main_window: QtWidgets.QMainWindow,
        discrete_radio_btn: QtWidgets.QRadioButton,
        int_cpu_radio_btn: QtWidgets.QRadioButton,
        owner_line_edit: QtWidgets.QLineEdit,
        generated_files_path: str,
    ):
        super().__init__()
        self.main_window = main_window
        self.discrete_radio_btn = discrete_radio_btn
        self.int_cpu_radio_btn = int_cpu_radio_btn
        self.gpu_location = None
        self.owner = owner_line_edit.text()
        self.generated_files_path = generated_files_path
        self.generate_files = None

        self.filters = []
        self.the_dir = None
        self.set_default_values()
        self.sudo_passwd = None
        self.use_sudo = True

        self.is_running = False

    def run(self) -> None:
        self.is_running = True
        self.startEvent.emit()
        self.gpu_location = (
            peracommon.GpuLocation.DISCRETE
            if self.discrete_radio_btn.isChecked()
            else peracommon.GpuLocation.CPU
            if self.int_cpu_radio_btn.isChecked()
            else peracommon.GpuLocation.MOTHERBOARD
        )
        result = []
        if self.generate_files:
            if sys.platform == "win32":
                from scripts.get_windows_specs import generate_win_files

                generate_win_files()
                self.process_win_files()
            else:
                message = peracommon.check_required_files(self.generated_files_path, is_gui=True)
                if message != "":
                    QtWidgets.QMessageBox.critical(self.main_window, "Error", message)
                self.generated_files_path = peracommon.generate_files(self.the_dir, self.use_sudo, self.sudo_passwd)
                if self.generated_files_path is None:
                    print("Wrong root password. Terminating peracotta...")
                    return
                result = peracommon.call_parsers(
                    self.generated_files_path,
                    set(self.filters),
                    self.gpu_location,
                    False,
                )
                if self.owner != "":
                    result = peracommon.add_owner(result, self.owner)
                result = peracommon.split_products(result)
        self.updateEvent.emit(result)
        self.set_default_values()

    def set_default_values(self):
        self.filters = []
        self.generate_files = False
        self.the_dir = "tmp"
        self.is_running = True
        self.sudo_passwd = None
        self.use_sudo = True

    def process_files(self):
        pass

    def process_win_files(self):
        pass

    def set_filters(self, widget: QtWidgets.QWidget):
        for checkbox in widget.findChildren(QtWidgets.QCheckBox):
            if checkbox.isChecked():
                self.filters.append(peracommon.ParserComponents(checkbox.text()))


class ItemEnumDelegate(QtWidgets.QStyledItemDelegate):
    # class ItemEnumAlignDelegate(QtWidgets.QStyledItemDelegate):
    #     def initStyleOption(self, option, index):
    #         super().initStyleOption(option, index)
    #         option.displayAlignment = QtCore.Qt.AlignLeft

    def createEditor(self, parent, option, index):
        the_type = str(index.model().data(index, QtCore.Qt.UserRole))
        if the_type == "e":
            editor = QtWidgets.QComboBox(parent)
            editor.currentTextChanged.connect(self.handle_editor_change)
            editor.setEditable(True)
            return editor
        else:
            return super().createEditor(parent, option, index)

    def setEditorData(self, editor, index):
        model: CustomTableModel = index.model()
        if isinstance(editor, QtWidgets.QComboBox):
            values = model.row_all_enum_values_for_editor(index.row())
            current = model.row_current_enum_value_for_editor(index.row())
            if values and current:
                # editor.setItemDelegate(self.ItemEnumAlignDelegate(editor))
                for k, v in values.items():
                    editor.addItem(v, k)
                    i = editor.count() - 1
                    if current == k:
                        editor.setCurrentIndex(i)
        else:
            return super().setEditorData(editor, index)

    def setModelData(self, editor, model, index):
        if isinstance(editor, QtWidgets.QComboBox):
            model.setData(index, editor.currentData(), QtCore.Qt.EditRole)
        else:
            return super().setModelData(editor, model, index)

    def handle_editor_change(self):
        editor = self.sender()
        self.commitData.emit(editor)
        self.closeEditor.emit(editor)


class CustomTableView(QtWidgets.QTableView):
    def __init__(self):
        super().__init__()
        self.setItemDelegateForColumn(1, ItemEnumDelegate())

    def minimumSizeHint(self) -> QtCore.QSize:
        default_size = super().minimumSizeHint()

        frame = self.frameWidth() * 2

        header = self.verticalHeader().sizeHint().height()
        rows = self.verticalHeader().length()
        # rows = self.model().rowCount() * self.horizontalHeader().defaultSectionSize()
        h = header + rows + frame
        # print(f"{header} + {rows} + {frame} = {h} > {default_size.height()}")

        return QtCore.QSize(default_size.width(), h)

    def contextMenuEvent(self, event: QtGui.QContextMenuEvent) -> None:
        menu = QtWidgets.QMenu(self)
        remove_action = QtWidgets.QAction("Remove feature", self)
        remove_action.triggered.connect(self.remove_row)
        menu.addAction(remove_action)
        menu.popup(QtGui.QCursor.pos())

    def remove_row(self):
        self.model().removeRow(self.selectedIndexes()[1].row(), self.selectedIndexes()[1].parent())


class ToolBoxItem(QtWidgets.QWidget):
    def __init__(self, data: List[dict], features: dict, product: Optional[dict], default_features: dict):
        super().__init__()
        self.default_features = default_features

        self.main_layout = QtWidgets.QVBoxLayout()
        self.table = CustomTableView()
        self.features_combo_box = QtWidgets.QComboBox()
        self.feature_line_edit = QtWidgets.QLineEdit()
        self.feature_selector = QtWidgets.QComboBox()
        self.add_feature_button = QtWidgets.QPushButton("Add")
        self.add_feature_button.clicked.connect(self.add_feature)
        self.add_feature_button.setMinimumWidth(60)

        # setup
        self.table_setup(data, features, product, default_features)
        self.adder_layout = self._create_feature_adder()
        self.main_layout.addLayout(self.adder_layout)
        self.setLayout(self.main_layout)

    def external_size_hint_height(self):
        h1 = max(self.table.minimumSizeHint().height(), self.table.sizeHint().height())
        h2 = self.adder_layout.sizeHint().height()

        return h1 + h2

    def table_setup(self, data: List[dict], features: dict, product: Optional[dict], default_features: dict):
        ctm = CustomTableModel(data, features, product, default_features)
        ctm.emergency_resize.connect(self._do_the_emergency_resize)
        self.table.verticalHeader().hide()
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.setModel(ctm)
        self.table.setShowGrid(False)
        self.table.setAlternatingRowColors(True)
        self.table.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.table.verticalScrollBar().hide()
        self.table.verticalScrollBar().resize(0, 0)
        self.main_layout.addWidget(self.table)
        self.table.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.AdjustToContents)
        self.table.resizeColumnsToContents()
        self.table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)

    def _do_the_emergency_resize(self):
        self.parentWidget().parentWidget().updateGeometry()
        # TODO: re-enable this IF AND ONLY IF:
        # TODO: 1. the last column stretches as it should, but doesn't
        # TODO: 2. it won't resize past the table width
        # self.table.resizeColumnsToContents()

    def _create_feature_adder(self):
        layout = QtWidgets.QHBoxLayout()
        layout.addWidget(self.features_combo_box)
        layout.addWidget(self.feature_line_edit)
        layout.addWidget(self.feature_selector)
        layout.addWidget(self.add_feature_button)
        for name in self.default_features["names"]:
            self.features_combo_box.addItem(self.default_features["names"][name])
        self.features_combo_box.currentTextChanged.connect(self.set_input_type)
        self.set_input_type()
        return layout

    def set_input_type(self):
        for the_type in self.default_features["types"]:
            if self.default_features["names"][the_type] == self.features_combo_box.currentText():
                # set input type
                if self.default_features["types"][the_type] == "e":
                    self.feature_line_edit.setHidden(True)
                    self.feature_selector.setHidden(False)
                    self.feature_selector.clear()
                    i = 0
                    for value in self.default_features["values"][the_type]:
                        self.feature_selector.addItem(self.default_features["values"][the_type][value])
                        self.feature_selector.setItemData(i, value)
                        i += 1
                else:
                    self.feature_line_edit.setHidden(False)
                    self.feature_selector.setHidden(True)
                # disable button if feature already in table
                if the_type in self.table.model().features_in_table():
                    self.set_add_control_enabled(False)
                else:
                    self.set_add_control_enabled(True)

    def add_feature(self):
        feature = list(self.default_features["types"])[self.features_combo_box.currentIndex()]
        if self.feature_line_edit.isVisible():
            value = self.feature_line_edit.text()
        elif self.feature_selector.isVisible():
            value = self.feature_selector.currentData()
        else:
            return
        model: CustomTableModel = self.table.model()
        ok = model.insert_row(feature, value)
        if ok:
            self.set_add_control_enabled(False)

    def set_add_control_enabled(self, flag: bool):
        self.add_feature_button.setEnabled(flag)
        self.feature_line_edit.setEnabled(flag)
        self.feature_selector.setEnabled(flag)

    def minimumSizeHint(self) -> QtCore.QSize:
        return self.table.minimumSizeHint()


class ToolBoxWidget(QtWidgets.QToolBox):
    def __init__(self, data: List[dict], default_features: dict, encountered_types_count: dict):
        super().__init__()
        self.data = data
        self.default_features = default_features
        self.encountered_types_count = encountered_types_count
        self.menu = None

        # variables
        self.encountered_types_current_count = defaultdict(lambda: 0)

    def clear(self):
        for idx in range(self.count()):
            self.removeItem(0)
        self.encountered_types_count.clear()
        self.encountered_types_current_count.clear()

    def load_items(self, data: List[dict]):
        if data:
            self.data = data
        self.clear()
        self.types_count()

        # find brand, model and variant of all products in data
        products = {}
        for idx, entry in enumerate(self.data):
            if entry["type"] == "P":
                products[idx] = (entry["brand"], entry["model"], entry["variant"])

        for entry in self.data:
            self.add_item(entry)

        # remove scroll in toolbox's scrollAreas
        for scroll_area in self.findChildren(QtWidgets.QScrollArea):
            scroll_area.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
            scroll_area.verticalScrollBar().hide()
            scroll_area.verticalScrollBar().resize(0, 0)

    def add_item(self, item: Optional[dict] = None, item_type: Optional[str] = None, single_item: Optional[bool] = False):
        if single_item:
            self.data.append(
                {
                    "type": "I",
                    "features": {
                        "type": item_type,
                    },
                }
            )
            found_product = None
        else:
            found_product = self.find_matching_product(self.data, item.get("features", {}))

        if item and item["type"] != "I":
            return

        counter = ""

        if item_type is None and item:
            item_type = item["features"]["type"]
        if self.encountered_types_count[item_type] > 1:
            self.encountered_types_current_count[item_type] += 1
            counter = f" #{self.encountered_types_current_count[item_type]}"
        if single_item:
            features = self.data[-1]["features"]
        else:
            features = item["features"]

        self.addItem(
            ToolBoxItem(self.data, features, found_product, self.default_features),
            f"{self.print_type_cool(item_type)}{counter}",
        )
        if item_type in ICON:
            icon = QtGui.QIcon(ICON[item_type])
            self.setItemIcon(self.count() - 1, icon)

        self.set_context_menu()

    @staticmethod
    def find_matching_product(data: List[dict], features: dict):
        if "model" in features and "brand" in features and "variant" in features:
            for maybe in data:
                if maybe.get("type") == "P":
                    if maybe.get("brand") == features["brand"] and maybe.get("model") == features["model"] and maybe.get("variant") == features["variant"]:
                        return maybe
        return None

    def set_context_menu(self):
        counter = 0
        for item in self.children():
            if type(item) == QtWidgets.QAbstractButton:
                item: QtWidgets.QAbstractButton
                item.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
                item.customContextMenuRequested.connect(self.show_menu)
                counter += 1

    def print_type_cool(self, the_type: str) -> str:
        if the_type in self.default_features["values"]["type"]:
            return self.default_features["values"]["type"][the_type]
        else:
            return the_type.title()

    def show_menu(self):
        button = self.sender()
        self.menu = QtWidgets.QMenu()
        remove_action = QtWidgets.QAction("Remove item", self)
        remove_action.triggered.connect(lambda: self.remove_item_from_toolbox(button))
        self.menu.addAction(remove_action)
        self.menu.popup(QtGui.QCursor.pos())

    def minimumSizeHint(self) -> QtCore.QSize:
        h = 0
        for child in self.children():
            if isinstance(child, QtWidgets.QScrollArea):
                if child.isHidden():
                    # print("Hidden!")
                    pass
                    # print(f"Hidden min {child.minimumSizeHint().height()}")
                    # print(f"Hidden {child.sizeHint().height()}")
                    # h += child.minimumSizeHint().height()
                else:
                    the_widget = child.widget()
                    if the_widget and isinstance(the_widget, ToolBoxItem):
                        hinted = the_widget.external_size_hint_height()
                        # print(f"Hinted: {hinted}")
                        h += hinted
                    else:
                        # h += max(child.sizeHint().height(), child.minimumSizeHint().height())
                        pass
            elif isinstance(child, QtWidgets.QAbstractButton):
                # print(f"{child}: {child.sizeHint().height()} {child.minimumSizeHint().height()}")
                # Why 1.5? Dunno, they're ~40 pixels and sizeHint is 25 (minimum 24).
                h += int(child.sizeHint().height() * 1.5)
        old = super().minimumSizeHint()
        if h > old.height():
            return QtCore.QSize(old.width(), h)
        return old

    def remove_item_from_toolbox(self, button):
        i = 0
        for item in self.children():
            if type(item) == QtWidgets.QAbstractButton:
                if item == button:
                    self.removeItem(i)
                    break
                else:
                    i += 1

    def removeItem(self, index: int) -> None:
        i = 0
        data_index = None
        for data_index, entry in enumerate(self.data):
            if entry["type"] != "I":
                continue
            if index == i:
                break
            i += 1

        item_to_remove = self.data[data_index]
        item_b = item_to_remove["features"].get("brand")
        item_m = item_to_remove["features"].get("model")
        item_v = item_to_remove["features"].get("variant")
        counter = 0
        product_index = None
        deleted = False
        if item_b and item_m and item_v:
            for idx, entry in enumerate(self.data):
                # count items with the same product
                if entry["type"] == "I" and idx != data_index:
                    test_b = entry["features"].get("brand")
                    test_m = entry["features"].get("model")
                    test_v = entry["features"].get("variant")
                    if item_b == test_b and item_m == test_m and item_v == test_v:
                        counter += 1
                # find the product itself
                elif entry["type"] == "P":
                    p_test_b = entry.get("brand")
                    p_test_m = entry.get("model")
                    p_test_v = entry.get("variant")
                    if item_b == p_test_b and item_m == p_test_m and item_v == p_test_v:
                        product_index = idx
            if counter <= 0 and product_index:
                # If both item and product have to be deleted, delete them
                # without f...messing up indexes
                if data_index >= product_index:
                    del self.data[data_index]
                    del self.data[product_index]
                else:
                    del self.data[product_index]
                    del self.data[data_index]
                deleted = True

        # All other cases (item with no product, product not found, other items linked to product):
        # just delete the product
        if not deleted:
            del self.data[data_index]

        widget_ref = self.widget(index)
        super().removeItem(index)
        widget_ref.deleteLater()

    def types_count(self, data: list = None):
        if data is not None:
            self.data = data
        for entry in self.data:
            if entry["type"] != "I":
                continue
            the_type = entry["features"]["type"]
            self.encountered_types_count[the_type] += 1


class CustomTableModel(QAbstractTableModel):
    emergency_resize = QtCore.pyqtSignal(name="emergency_resize")

    def __init__(self, data: List[dict], item_features: dict, product: Optional[dict], default_features: dict):
        super().__init__()

        self._data = data
        self.ref_features = item_features
        self.ref_product = product
        self.default_features = default_features

        self.features = {}
        self.feature_keys = []
        self._productize(item_features, product)

    def _productize(self, item_features: dict, product: Optional[dict]):
        if product:
            self.features = product["features"].copy()
        else:
            self.features = {}
        self.features.update(item_features)
        self.feature_keys = list(self.features)

    def rowCount(self, parent=QtCore.QModelIndex()):
        return len(self.feature_keys)

    def columnCount(self, parent=QtCore.QModelIndex()):
        return 2

    # noinspection PyMethodOverriding
    def headerData(self, section, orientation, role):
        if role == QtCore.Qt.DisplayRole and orientation == QtCore.Qt.Horizontal:
            if section == 0:
                return "Feature"
            else:
                return "Value"
        return None

    def flags(self, index):
        if index.column() == 1:
            return QtCore.Qt.ItemIsEditable | QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsSelectable
        else:
            return QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsSelectable

    def row_all_enum_values_for_editor(self, row: int) -> Optional[dict[str, str]]:
        if row < 0 or row >= len(self.feature_keys):
            return None

        name = self.feature_keys[row]
        feature_type = self._get_feature_type(name)
        if feature_type == "e":
            return self.default_features["values"][name]
        return None

    def row_current_enum_value_for_editor(self, row: int):
        if row < 0 or row >= len(self.features):
            return None

        name = self.feature_keys[row]
        return self.features.get(name)

    # def _row_to_name(self, row) -> Optional[str]:
    #     for i, name in enumerate(self.combined):
    #         if i == row:
    #             return name
    #         else:
    #             return None

    def data(self, index, role=QtCore.Qt.DisplayRole):
        row = index.row()
        if row < 0 or row >= len(self.feature_keys):
            return None

        if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole or role == QtCore.Qt.UserRole:
            column = index.column()
            name = self.feature_keys[row]
            if column == 0:
                return self.default_features["names"].get(name, name)
            elif column == 1:
                feature_type = self._get_feature_type(name)
                if role == QtCore.Qt.UserRole:
                    return feature_type
                value = self.features[name]
                if feature_type == "e":
                    return self.default_features["values"][name].get(value, value)
                elif feature_type in ("d", "i"):
                    return prettyprinter.print_feature(name, value, feature_type)
                else:
                    return value
        elif role == QtCore.Qt.TextAlignmentRole:
            column = index.column()
            if column == 0:
                return QtCore.Qt.AlignLeft + QtCore.Qt.AlignVCenter
            elif column == 1:
                return QtCore.Qt.AlignLeft + QtCore.Qt.AlignVCenter

        return None

    # noinspection PyMethodOverriding
    def setData(self, index, value, role):
        if role == QtCore.Qt.EditRole:
            row = index.row()
            col = index.column()
            if col != 1:
                return False
            if row < 0 or row >= len(self.feature_keys):
                return False

            name = self.feature_keys[row]
            ok, value = self.extreme_validation(name, value)
            if ok:
                self.features[name] = value
                product_to_add = None
                if not self.ref_product:
                    product_to_add = ToolBoxWidget.find_matching_product(self._data, self.features)
                    if product_to_add:
                        self.beginResetModel()
                        self._productize(self.features, product_to_add)
                if self.ref_product and name in self.ref_product["features"]:
                    self.ref_product["features"][name] = value
                elif name in self.ref_features:
                    self.ref_features[name] = value
                else:
                    self._add_to_ref(name, value)
                if product_to_add:
                    self.endResetModel()
                    self.emergency_resize.emit()
            return ok
        return False

    def extreme_validation(self, name: str, value: [str, int, float]) -> [bool, [str, int, float]]:
        feature_type = self._get_feature_type(name)
        if isinstance(value, str):
            value = value.strip()
        if feature_type == "e":
            value = str(value).lower()
            if value not in self.default_features["values"][name]:
                return False, None
        elif feature_type == "d":
            value = self._printable_to_value(name, value)
            value = float(value)
            if value <= 0:
                return False, None
        elif feature_type == "i":
            value = self._printable_to_value(name, value)
            value = int(round(value))
            if value <= 0:
                return False, None
        else:
            if len(value) <= 0:
                return False, None
        return True, value

    def removeRow(self, row: int, parent: QtCore.QModelIndex() = ...) -> bool:
        # TODO: remove this limitation asd
        if not self._pre_delete_check(row):
            return False

        self.beginRemoveRows(parent, row, row)
        try:
            removed = self.feature_keys.pop(row)
            try:
                del self.features[removed]
                # TODO: remove from features but show product one if it exists
                if removed in self.ref_features:
                    del self.ref_features[removed]
                if self.ref_product and removed in self.ref_product["features"]:
                    del self.ref_product["features"][removed]
            except IndexError:
                pass
        except IndexError:
            self.endRemoveRows()
            return False
        self.endRemoveRows()
        return True

    def _pre_delete_check(self, row) -> bool:
        feature_name = self.feature_keys[row]
        if self.features.get(feature_name) in ("brand", "model", "variant"):
            if self.ref_product:
                return False
        return True

    @staticmethod
    def _printable_to_value(name, value):
        # noinspection PyBroadException
        try:
            value = prettyprinter.printable_to_value(prettyprinter.name_to_unit(name), value)
        except BaseException:
            value = 0
        return value

    def _get_feature_type(self, name):
        feature_type = self.default_features["types"].get(name, "s")
        return feature_type

    def insert_row(self, feature: str, value: str) -> bool:
        if feature in self.feature_keys:
            return False

        row_index = self.rowCount()

        ok, value = self.extreme_validation(feature, value)
        product_to_add = None
        if ok:
            self.beginInsertRows(QtCore.QModelIndex(), row_index, row_index)
            self.feature_keys.append(feature)
            self.features[feature] = value
            if not self.ref_product:
                product_to_add = ToolBoxWidget.find_matching_product(self._data, self.features)
            self._add_to_ref(feature, value)
            self.endInsertRows()

        if product_to_add:
            self.beginResetModel()
            self._productize(self.features, product_to_add)
            self.endResetModel()

        self.emergency_resize.emit()

        return ok

    def features_in_table(self):
        return self.feature_keys

    def _add_to_ref(self, name: str, value):
        if name in peracommon.item_only_features():
            target = self.ref_features
        elif self.ref_product:
            target = self.ref_product["features"]
        else:
            target = self.ref_features
        target[name] = value


class JsonWidget(QtWidgets.QDialog):
    def __init__(self, data: List[dict], window_size: QtCore.QSize):
        super().__init__()
        layout = QtWidgets.QVBoxLayout()
        text_edit = QtWidgets.QPlainTextEdit()
        text_edit.setWordWrapMode(QtGui.QTextOption.NoWrap)
        text_edit.setPlainText(f"{json.dumps(data, indent=2)}")
        text_edit.setReadOnly(True)
        layout.addWidget(text_edit)
        self.setLayout(layout)
        new_size = QtCore.QSize(int(window_size.width() * 0.8), int(window_size.height() * 0.8))
        self.resize(new_size)
        self.exec_()


class TaralloUploadDialog(QtWidgets.QDialog):
    signal = QtCore.pyqtSignal(bool, bool, str, name="event")

    def __init__(self, bulk_id: str = ""):
        super().__init__()
        uic.loadUi(PATH["TARALLOUPLOADDIALOG"], self)

        self.setWindowTitle("Set bulk identifier")
        self.bulkLineEdit = self.findChild(QtWidgets.QLineEdit, "bulkLineEdit")
        self.bulkLineEdit.setText(bulk_id)
        self.okButton = self.findChild(QtWidgets.QPushButton, "okButton")
        self.okButton.clicked.connect(self.ok_signal)
        self.cancelButton = self.findChild(QtWidgets.QPushButton, "cancelButton")
        self.cancelButton.clicked.connect(self.cancel_signal)
        self.overwriteCheckBox = self.findChild(QtWidgets.QCheckBox, "overwriteCheckBox")

    def ok_signal(self):
        self.signal.emit(self.overwriteCheckBox.isChecked(), self.bulkLineEdit.text())
        self.close()

    def cancel_signal(self):
        self.close()


class Uploader(QtCore.QThread):
    successEvent = QtCore.pyqtSignal(str)
    failureEvent = QtCore.pyqtSignal(str, str)

    def __init__(
        self,
        data: List[dict],
        tarallo_url: str,
        tarallo_token: str,
        bulk_identifier: str,
        overwrite: bool,
    ):
        super().__init__()
        self.data = data
        self.tarallo_url = tarallo_url
        self.tarallo_token = tarallo_token
        self.bulk_identifier = bulk_identifier
        self.overwrite = overwrite

    def run(self) -> None:
        try:
            tarallo = Tarallo.Tarallo(self.tarallo_url, self.tarallo_token)
            ver = tarallo.bulk_add(self.data, self.bulk_identifier, self.overwrite)
            if ver:
                # TODO: use generated identifier if none was provided
                self.successEvent.emit(self.bulk_identifier)
            else:
                self.failureEvent.emit("cannot_upload", self.bulk_identifier)

        except NoInternetConnectionError:
            self.failureEvent.emit("cannot_reach", self.bulk_identifier)


def tarallo_success_dialog(url: str):
    dialog = QtWidgets.QMessageBox(
        QtWidgets.QMessageBox.Information,
        "Upload successful",
        "Upload successful! Now go to TARALLO and finish the job.",
    )
    std_width = QtWidgets.QApplication.style().standardIcon(QtWidgets.QStyle.SP_MessageBoxWarning).availableSizes()[-1].width()
    dialog.setIconPixmap(QtGui.QPixmap(PATH["ICON"]).scaledToWidth(std_width, QtCore.Qt.SmoothTransformation))
    dialog.setStandardButtons(QtWidgets.QMessageBox.Ok)
    view_on_tarallo_button = dialog.addButton("View on TARALLO", dialog.ActionRole)
    dialog.exec_()
    if dialog.clickedButton() == view_on_tarallo_button:
        url = QtCore.QUrl(url)
        if not QtGui.QDesktopServices.openUrl(url):
            QtWidgets.QMessageBox.warning(dialog, "Cannot Open Url", f"Could not open url {url}")
        return True
    return False


def main():
    # noinspection PyBroadException
    try:
        load_dotenv()
        tarallo_url = env["TARALLO_URL"]
        tarallo_token = env["TARALLO_TOKEN"]
        auto_download = env_to_bool(env.get("TARALLO_FEATURES_AUTO_DOWNLOAD", "1"))
        app = QtWidgets.QApplication(sys.argv)
        # This is EXTREMELY IMPORTANT, DON'T TACH [sic], DO NOT REMOVE IT EVER
        # noinspection PyUnusedLocal
        window = Ui(app, tarallo_url, tarallo_token, auto_download)
        app.exec_()

    except KeyboardInterrupt:
        print("KeyboardInterrupt")

    except BaseException:
        print(traceback.print_exc(file=sys.stdout))


if __name__ == "__main__":
    main()
